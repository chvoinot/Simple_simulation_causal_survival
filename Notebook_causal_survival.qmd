---
title: "Causal survival analysis"
subtitle: "Estimation de l'Effet Moyen du Traitement (ATE) en survie causale: Comparaison, Applications et Recommandations Pratiques"
author:
  - name: Charlotte Voinot
    corresponding: true
    email: charlotte.voinot@sanofi.com
    url: https://chvoinot.github.io/
    affiliations:
      - name: Sanofi
        department: CMEI
        url: https://www.sanofi.fr/fr/
      - name: INRIA
        department: Premedical
        url: https://www.inria.fr/fr/premedical
date: last-modified
date-modified: last-modified
keywords: [Causal survival, Causal inference, ATE, Censoring]
bibliography: references.bib
github-user: chvoinot
repo: "Simple_simulation_causal_survival"
draft: true # set to false once the build is running
published: false # will be set to true once accepted
format:
  computo-html: default
  computo-pdf: default
editor: 
  markdown: 
    wrap: 72
---

# Background

Causal survival analysis can be seen as the combination of causal
analysis and survival analysis: the aim is to assess the causal effect
of a treatment or an intervention on a outcome which is a time until an
event occurs. The objective of this article is to provide a
comprehensive overview of the different available methods to estimate
the (average) effect of a treatment on survival.

## Notations

Let's consider a sample of $n$ i.i.d observations that are described by:

-   $X_{i}$: the covariates, $X \in \mathbb{R}^p$.

-   $A_{i}$: the binary treatment, $A \in \{0, 1\}$.

-   $C_{i}$: the time to censoring, $C \in \mathbb{R}^+$.

-   $T_{i}(0)$: the survival time to the event of interest had the
    patient received control $A_{i}=0$.

-   $T_{i}(1)$: the survival time to the event of interest had the
    patient received treatment $A_{i}=1$.

-   $T_{i} =A_{i} T_{i}(1)+(1-A_{i}) T_{i}(0)$, $T \in \mathbb{R}^+$:
    the observed outcome corresponds to the potential outcome under the
    assigned treatment; this is known as the consistency identifiability
    assumption in causal inference.

-   $\Delta_{i}=I\{T_{i} \leq C_{i}\}$ the status of censoring, where
    $I\{\cdot\}$ is the indicator.

-   $\tilde{T_{i}}= T_{i} \wedge C_{i} = \min(T_i,C_i)$, the observed
    time. When an observation is censured, then its observed time is
    equal to the censoring time.

The observed data can be summarized as a quadruplet
($X_{i},A_{i},\Delta_{i},\tilde{T_{i}}$) represented in
@tbl-exemple_data.

| ID  | Covariates 1 | Covariates 2 | Covariates 3 | Treatment | Censoring | Status   | Outcomes | Outcomes | Outcomes | Outcomes    |
|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| ID  | $X_{1}$      | $X_{2}$      | $X_{3}$      | A         | C         | $\Delta$ | T(0)     | T(1)     | T        | $\tilde{T}$ |
| 1   | 1            | 1.5          | 4            | 1         | ?         | 1        | ?        | 200      | 200      | 200         |
| 2   | 5            | 1            | 2            | 0         | ?         | 1        | 100      | ?        | 100      | 100         |
| 3   | 9            | 0.5          | 3            | 1         | 200       | 0        | ?        | ?        | ?        | 200         |

: Example of survival data with covariates, treatment, the censoring
time, the status of censoring and the potential outcomes and observed
outcomes. {#tbl-exemple_data}

## Treatment effect

In causal inference, the primary goal is to estimate the individual
causal effect of the treatment denoted as $\theta_i = T_i(1) - T_i(0)$
[@rubin_estimating_1974],[@hernan2010causal]. However, this quantity
cannot be observed because at most one outcome can be observed per
sample (see @tbl-exemple_data). Furthermore, censoring may also mask
outcomes [@censoring_effect]. Despite these challenges, certain
identifiability assumptions enable us for estimating the average
treatment effect [@RMST_estimator], [@RMST_estimator2] (ATE) which is
defined as follows:

::: {#def-ATE}
## Causal effect: Average treatment effect in survival analysis (ATE)

$$
\theta = \mathbb{E}\left[y(T(1)) - y(T(0))\right] 
$$

-   $y(T) = T \wedge \tau = \min(T,\tau)$ with $\tau$ a fixed time
    horizon; then, $E(y(T))$ becomes the restricted mean survival time
    (RMST) at time $\tau$ [@RMST].
    
-   $y(T) = \int_0^{\tau}I\{T > t\}dt$ for $t \leq \tau$. Indeed, $T \wedge \tau = \int_0^{T \wedge \tau}1dt= \int_0^{\tau}I\{T > t\}dt$, so we have $E(T \wedge \tau)=\int_0^\tau S(t)dt$ 


:::

Thus, the average treatment effect can be expressed in two ways in using the RMST : 


::: {#def-causalmin}
## Causal effect: Difference of restricted mean survival time (RMST) between treated and controls

$$
\begin{aligned}
   \theta_{RMST}(\tau)  = \mathbb{E}\left[T(1) \wedge \tau - T(0) \wedge \tau\right]  
\end{aligned}
$$

Survival probabilities and RMST are linked as follows: 
$$
\begin{aligned}
     \theta_{RMST}(\tau) = &= E\left[\int_0^{\tau}I\{T(1) > t\}dt -\int_0^{\tau}I\{T(0) > t\}dt\right] \\
    &=\int_{0}^{\tau}{\mathbb{E}[I\{T(1) > t\}]dt - \int_{0}^{\tau}\mathbb{E}[I\{T(0) > t\}]dt }\\
    &= \int_0^\tau S_1(t) - \int_0^\tau S_0(t)dt \\
    &= \int_0^\tau [S_1(t) - S_0(t)]dt 
\end{aligned}
$$
with $S_a(t) = P(T(a)>t)$, the probability of surviving at time $t$
when treatment $A=a$.
:::

RMST can be interpreted as the average survival time from baseline to a
pre-specified time $\tau$: a RMST value of $10$ days with $\tau=200$
means that on average the treatment increases the survival time by 10
days at 200 days.

In this paper, we focus on $\theta_{RMST}$ as the estimand of interest.\
The aim is to construct estimators of this average causal effect while
overcoming potential biases due to confounding factors and to right
censoring.

## Censoring mechanism

Two different assumptions about the censoring mechanism can be
considered.

::: {#as-IndependantCensoring .assumption}
**Assumption 1:Independent/ Non informative censoring**

$$ 
C \perp\mkern-9.5mu\perp T(0),T(1),X,A 
$$ {#eq-independantcensoring}
:::

Under @eq-independantcensoring, subjects censored at time $t$ are
representative of all subjects who remain at risk at time $t$.
Therefore, the probability of experiencing an event should be the same
for both censored subjects and subjects remaining at risk. It is as if
the censored subjects were randomly selected from all subjects.

::: assumption
**Assumption 2:Conditionally independent censoring**

$$ 
 C \perp\mkern-9.5mu\perp T(0),T(1)|X,A 
$$ {#eq-condindepcensoring}
:::

Under @eq-condindepcensoring, within subgroups represented by $X=x$,
subjects censored at time $t$ are representative of all subjects in
their subgroup who remain at risk at time $t$. It is as if the censored
subjects were randomly selected inside each subgroup. This assumption is
also referred to as dependent censoring.

But another assumption for identifiability of RMST is required under
@eq-condindepcensoring: we need to assume that all subjects have a
positive probability to remain uncensored at their failure time.

::: assumption
**Assumption 3:Positivity / Overlap for censoring**

$$ 
pr( C > t \mid X=x, A=a) > 0, \text{ \quad for the identifiability of RMST: $t\leq \tau$}.
$$ {#eq-positivitycensoring}
:::

If for a time $t$, $\mathbb{P}( C > t \mid X=x, A=a) = 0$, then this
excludes that we have any observed outcomes after time $t$. For example,
if we consider a clinical trial with administrative censoring after one
year of study, then the probability of remaining uncensored after one
year is zero. In that case, the potential outcomes $T(0)$ and $T(1)$ are
not observed at all after $t=1$ year. One can consider lowering the
threshold time $\tau$ such that each subject has a probability of
remaining uncensored at their restricted time. \# Causal survival
analysis with a Randomized Control Trial

Randomized clinical trials (RCTs) are the gold standard for establishing
the effect of a treatment on an outcome, because treatment allocation is
under control, which ensures (asymptotically) the balance of covariates
between treated and controls, and thus avoids problems of confounding
between covariables and treatment.

The core assumption in a RCT is the random assignment of the treatment
[@rubin_estimating_1974].

::: assumption
**Assumption 4:Random treatment assignment**

$$ 
A \perp\mkern-9.5mu\perp(T(0),T(1),X)
$$ {#eq-randomization}
:::

@eq-randomization implies that the treatment is given at random and is
independent of both the potential outcomes and the covariates.

**Indentifiability**

Under @eq-randomization (random treatment assignment) and
@eq-independantcensoring (independent censoring), the RMST can be
identified as follows:

$$
\begin{aligned}
    \theta_{RMST} &=  \mathbb{E}[T(1) \wedge \tau - T(0) \wedge \tau]\\
    &= \mathbb{E}[T(1) \wedge \tau] - \mathbb{E}[T(0) \wedge \tau]\\
    &= \mathbb{E}[T(1) \wedge \tau|A=1] - \mathbb{E}[T(0) \wedge \tau|A=0]  && \tiny\text{(Random treatment assignment)}\\
    &= \mathbb{E}[T \wedge \tau|A=1] - \mathbb{E}[T \wedge \tau|A=0] && \tiny\text{(By consistency)}\\
    &= \int_{0}^{\tau}{\mathbb{P}(T>t|A=1) - \mathbb{P}(T>t|A=0) dt} \\
    &= \int_{0}^{\tau}{S(t|A=1)-S(t|A=0)dt}\\
\end{aligned}
$$ {#eq-RMSTkm} where $S(t|A=a)$ is the survival function of the
population with treatment $A=a$.

Under @eq-randomization (random treatment assignment) and
@eq-condindepcensoring (conditionally independent censoring), the RMST
can be identified as follows:

$$
\begin{aligned}
    \theta_{RMST}&=  \mathbb{E}[T(1) \wedge \tau - T(0) \wedge \tau] \\
    &= \int_{0}^{\tau}{\mathbb{E}[I\{T(1) > t\}] - \mathbb{E}[I\{T(0) > t\}]dt }\\
    &= \int_{0}^{\tau}{\mathbb{E}\left[\mathbb{E}[I\{T>t\}|A=1,X,T] \right]-\mathbb{E}\left[\mathbb{E}[I\{T>t\}|A=0,X,T] \right]} && \tiny\text{(Law of total probability)}  \\
    &= \int_{0}^{\tau}{\mathbb{E}\left[\frac{\mathbb{E}[I\{T > t|A=1,X,T\}]*\mathbb{E}[I\{T \wedge \tau < C|A=1,X,T\}]}{S_c(T(1) \wedge \tau|X,A=1)} \right] - \mathbb{E}\left[\frac{\mathbb{E}[I\{T > t|A=0,X,T\}]*\mathbb{E}[I\{T \wedge \tau < C|A=0,X,T\}]}{S_c(T(0) \wedge \tau|X,A=0)} \right]dt } \\
    &=\int_{0}^{\tau}{\mathbb{E}\left[\frac{\mathbb{E}[I\{T > t|A=1,X,T\}*I\{T \wedge \tau < C|A=1,X,T\}]}{S_c(T(1) \wedge \tau|X,A=1)}\right]- \mathbb{E}\left[\frac{\mathbb{E}[I\{T > t|A=0,X,T\}*I\{T \wedge \tau < C|A=0,X,T\}]}{S_c(T(0) \wedge \tau|X,A=0)} \right]dt} \\
    &= \int_{0}^{\tau}{\mathbb{E}\left[\frac{I\{T > t|A=1\}*\Delta^{\tau}}{S_c(T(1) \wedge \tau|X,A=1)}\right]- \mathbb{E}\left[\frac{I\{T > t|A=0\}*\Delta^{\tau}}{S_c(T(0) \wedge \tau|X,A=0)} \right]dt} && \tiny\text{(First possible estimator)} \\
    &= \mathbb{E}\left[\frac{A_i*\widetilde{T} \wedge \tau*\Delta^{\tau}}{S_c(T(1) \wedge \tau|X,A=1)}\right]- \mathbb{E}\left[\frac{(1-A_i)\widetilde{T} \wedge \tau*\Delta^{\tau}}{S_c(T(0) \wedge \tau|X,A=0)} \right] && \tiny\text{(Second possible estimator)} 
\end{aligned}
$$ {#eq-RMSTipcw}

where $S_c(T \wedge \tau|X,A=a)$ is the survival function of remain
uncensored troncated at $\tau$ given the covariate $X_i$ in the
treatment arm $A=a$ and $\Delta^{\tau}=I\{T \wedge \tau < C|A=1,X,T\}$
is the status of the individual troncated at $\tau$.

## Estimation under independent censoring

### Non adjusted Kaplan Meier estimator

::: {#def-km}
#### Unadjusted kaplan meier estimator {#sec-KM}

```{=tex}
\begin{align*}
    \hat{S}_{KM}(t \mid a) &= \prod_{j=1, t_j<=t}\left(1-\frac{\sum_i I\left\{T_i=t_j, C_i \geq t_j, A_i=a\right\}}{\sum_k I\left\{T_k \geq t_j, C_k \geq t_j, A_k=a\right\}}\right) \\
    &= \prod_{j=1, t_j<=t}\left(1-\frac{\sum_i I\left\{\tilde{T_i}=t_j, \Delta_i=1, A_i=a\right\}}{\sum_k I\left\{\tilde{T_k} \geq t_j, A_i=a\right\}}\right)
\end{align*}
```
:::

Unadjusted Kaplan Meier which maximizes the likelihood of the
observations is a uniformly consistent non parametric estimator for
estimating the survival function [@Kaplan_consistency] and [@kaplan].

The corresponding RMST is obtained in integrating from 0 to $\tau$ the
difference between non adjusted kaplan meier estimator of the treated
and controls @eq-RMSTkm : 

$$
     \theta_{RMST}(\tau) = \int_{0}^{\tau}\left( S_1(t) - S_0(t) \right)dt
$$

**Implementation**

```{r}
library(survival)
library(survminer)
# Fonction pour calculer l'intégrale par la méthode des trapèzes pour fonction decroissante 
trapezoidal_integration <- function(x, y) {
  sum((x[-1]-x[-length(x)]) * (y[-length(y)]+(y[-1]-y[-length(y)])/2))
}

#Handmade KM 
# kaplan meier estimator
Kaplan_meier_handmade <- function(data,status=data$status,T_obs=data$T_obs){
  Y.grid <- sort(unique(T_obs))
  d <- rep(NA,length(Y.grid))
  n <- rep(NA,length(Y.grid))
  S <- rep(NA,length(Y.grid))
  for (i in 1:length(Y.grid)){
    d[i] <- sum(T_obs==Y.grid[i] & status ==1,na.rm = TRUE)
    n[i] <- sum(T_obs >= Y.grid[i])
  }
  S <- cumprod(1-d/n)
  df<-data.frame(d=d,n=n,S= S, T = Y.grid)
  return(df)
}

# Kaplan meier adjusted
# Times of event 
# Failures : 1 if event 0 if censored
# Variable : 1 if treated 0 if control
# Weights : weight of the individual
adjusted.KM <- function(times, failures, variable, weights = NULL) {
  if (sum(times < 0) > 0) {
    print("Error: times must be positive")
  } else {
    if (sum(weights < 0) > 0) {
      print("Error: weights must be superior to 0")
    } else {
      if (sum(failures != 0 & failures != 1) > 0) {
        print("Error: failures must be a vector of 0 or 1")
      } else {
        if (is.null(weights)) {
          .w <- rep(1, length(times))
        } else {
          .w <- weights
        }
        
        .data <- data.frame(t = times, f = failures, v = variable, w = .w)
        .data <- .data[!is.na(.data$v),]
        Table <- data.frame(times = NULL, n.risk = NULL, n.event = NULL, survival = NULL, variable = NULL)
        
        for (i in unique(variable)) {
          .d <- .data[.data$v == i,]
          .tj <- c(0, sort(unique(.d$t[.d$f == 1])), max(.d$t))
          .dj <- sapply(.tj, function(x) {
            sum(.d$w[.d$t == x & .d$f == 1])
          })
          .nj <- sapply(.tj, function(x) {
            sum(.d$w[.d$t >= x])
          })
          .st <- cumprod((.nj - .dj) / .nj)
          Table <- rbind(Table, data.frame(T = .tj, n = .nj, d = .dj, S = .st, variable = i))
        }
        return(Table)
      }
    }
  }
}


```

We implement four methods to compute the RMST:

-   The first method consists in using a handmade estimator of the
    Kaplan meier survival function and then to compute the RMST by
    integrating the difference between the two survival functions
    between 0 and $\tau$.

-   The second method consists in using the handmade estimator of the
    Kaplan meier survival function after truncating the data at $\tau$
    and then compute the RMST by integrating the difference between the
    two survival functions.

-   The third method consists in using the survfit function from the
    survival [@survival] package on the the truncated data to compute
    the RMST in integrating the difference between the two survival
    functions.

-   The fourth method consists in computing the RMST in using the
    package survRM2 [@survRM2] which is a package for the estimation of
    the restricted mean survival time in the presence of right-censoring
    and the package suvrival [@survival] for fitting the kaplan meier
    estimator.

```{r}
RMST_1_2 <-function(data,A1=1,A0=0,tau=20){
  #T_obs <- sort(data$T_obs)
  # Method 1 : Handmade KM with no troncation 
  data1 <- data[data$A==A1,]
  data0 <- data[data$A==A0,]
  Y.grid1 <- data1$T_obs[data1$T_obs <= tau]
  Y.grid0 <- data0$T_obs[data0$T_obs <= tau]
  S_A1 <- Kaplan_meier_handmade(data1,status=data1$status,T_obs=data1$T_obs)
  S_A0 <- Kaplan_meier_handmade(data0,status=data0$status,T_obs=data0$T_obs)
  S_A1 <- S_A1%>%
    dplyr::filter(T %in% Y.grid1)

  S_A0 <- S_A0%>%
    dplyr::filter(T %in% Y.grid0)

  #integral from 0 to tau of S_A1 on Y.grid
  intA1 <- trapezoidal_integration(S_A1$T, S_A1$S)
  intA0 <- trapezoidal_integration(S_A0$T, S_A0$S)
  #mean(S_A1$T)
  RMST1 <- intA1 - intA0
  
  #Method 2 : Troncation
  data1$T_obs_tau2 <- ifelse(data1$T_obs>=tau,tau,data1$T_obs)
  data0$T_obs_tau2 <- ifelse(data0$T_obs>=tau,tau,data0$T_obs)
  data1$status_tau2 <- ifelse(data1$T_obs>=tau | (data1$T_obs < tau & data1$status ==1),1,0)
  data0$status_tau2 <- ifelse(data0$T_obs>=tau | (data0$T_obs < tau & data0$status ==1),1,0)
  
  S_A1 <- Kaplan_meier_handmade(data1,status=data1$status_tau2,T_obs=data1$T_obs_tau2)
  #plot(S_A1$T,S_A1$S)
  S_A0 <- Kaplan_meier_handmade(data0,status=data0$status_tau2,T_obs=data0$T_obs_tau2)
  intA1 <- trapezoidal_integration(S_A1$T, S_A1$S)
  intA0 <- trapezoidal_integration(S_A0$T, S_A0$S)
  RMST2 <- intA1 - intA0
  
  return(list(RMST1=RMST1,RMST2=RMST2))
}

#RMST_1_2(data,A1=1,A0=0,tau=20)
#RMST_min(data,tau=20)


# 3rd kaplan meier estimator with restricted tau : In using rmean 
# fit KM
RMST_3 <- function(data,tau=10){
  data$T_obs_tau <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$status_tau <- ifelse(data$T_obs>=tau | (data$T_obs < tau & data$status ==1),1,0)
  fit <- survfit(Surv(T_obs_tau, status_tau) ~ A, data = data)
  # Summarize table 
  res.sum <- surv_summary(fit, data = data)
  head(res.sum)
  res_KM <- attr(res.sum, "table") 
  head(res_KM)

  # Mean difference of the survival function 
  mean_naive <- (res_KM$rmean[2] - res_KM$rmean[1])
  return(mean_naive)
}

#RMST_3(data,tau=20)

# Fourth method : survRM2
library(survRM2)
RMST_4 <- function(data,tau=20){
  data$T_obs_tau2 <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$status_tau2 <- ifelse(data$T_obs>=tau | (data$T_obs < tau & data$status ==1),1,0)
  #fit <- survfit(Surv(T_obs, status) ~ A, data = data)
  arm <- data$A
  RMST <- rmst2(data$T_obs_tau2, data$status_tau2, arm=arm, tau = tau)
  return(RMST[[5]][1])
}

#RMST_4(data,tau=20)

```

The results of the four methods are presented in the section
@sec-simulation.

## Estimation under conditional censoring

Under Assumptions @eq-randomization (random treatment assignment),
@eq-condindepcensoring (conditional censoring) and
@eq-positivitycensoring (Positivity for censoring), the unadjusted KM
estimator overestimates the real survival probabilities [@IPCW]. This
indicates that correction for the presence of dependent censoring is
important in order to obtain a good estimator. Under these assumptions,
the adjusted IPCW (inverse probability of censoring weighting) Kaplan
Meier estimator [@Robins1992],[@IPCWrobins] can be used to estimate the
causal treatment effect.

### (IPCW) adjusted Kaplan Meier estimator

::: {#def-ipcwkm}
#### IPCW adjusted kaplan meier estimator

$$
\begin{aligned}
\hat{S}_{IPCW-KM}(t \mid a) &= \prod_{j=1, t_j<=t}\left(1-\frac{\sum_i \hat{w}_{i}(t_j,X_i)*I\left\{\widetilde{T_i}=t_j, C_i \geq t_j, A_i=a\right\}}{\sum_k \hat{w}_{k}(t_j,X_k)*I\left\{\widetilde{T_k} \geq t_j, C_k \geq t_j, A_k=a\right\}}\right) 
\end{aligned}
$$

-   $\hat{w_{i}}(t,X_i)=\frac{1}{\hat{S_{c}}(t|X_{i},A_{i})}$ is the
    inverse of the probability of remain uncensored given the covariates
    $X_{i}$.
-   $\hat{S_{c}}(t|X_{i},A_{i})$ is based on the fit of semi-parametric
    or parametric model for censoring (for example a Cox model) with
    $X_i$ and $A_i$ the covariates.
:::

The probability of remaining uncensored depends on the covariates and
the treatment, so subject with the same covariates have the same
probability of remaining uncensored. Thus, the corresponding weights in
this estimator give extra weight to subjects who are not censored in the
same group of subject with the same covariates in order to compensate
the dependent censoring.

At every time point $t$, each subject $i$ is given a weight which is
inversely proportional to the estimated probability of having remained
uncensored until time $t$.

In the exact same way than before, the corresponding RMST is obtained in
integrating from 0 to $\tau$ the difference between adjusted kaplan
meier estimator of the treated and controls @eq-RMSTipcw :

$$
     \theta_{RMST}(\tau) = \int_{0}^{\tau}\left( S_1(t) - S_0(t) \right)dt
$$

**Implementation**

```{r}
#function which compute rmst in having tau and the two survival function 
RMST_fromS <- function(S_A1, S_A0,tau){
  Y.grid1 <- S_A1$T[S_A1$T <= tau]
  Y.grid0 <- S_A0$T[S_A0$T <= tau]
  S_A1 <- S_A1%>%
    dplyr::filter(T %in% Y.grid1)

  S_A0 <- S_A0%>%
    dplyr::filter(T %in% Y.grid0)

  #integral from 0 to tau of S_A1 on Y.grid
  intA1 <- trapezoidal_integration(S_A1$T, S_A1$S)
  intA0 <- trapezoidal_integration(S_A0$T, S_A0$S)
  #mean(S_A1$T)
  RMST <- intA1 - intA0
  return(list(intA1=intA1,intA0=intA0,RMST=RMST))
}

library(riskRegression)
# estimate survival function with covariates for each individuals at each time Y.grid
estimate_survival_function <-function(DATA,X_name,Y.grid,type_of_model="cox",T_obs="T_obs",status="status"){
  if (type_of_model == "cox"){
    outcome <- paste(c('Surv(',T_obs,',',status,')'),collapse="")
    #outcome <- 'Surv(T_obs,status)'
    f <- as.formula(paste(outcome, paste(c(X_name,'A'), collapse = " + "), sep = " ~ "))
    fitS <- suppressWarnings(coxph(f, data=DATA, x=TRUE))
    fitS$coefficients[is.na(fitS$coefficients)] <- 0
    DATA.1 <- DATA
    DATA.1$A <- 1
    DATA.0 <- DATA
    DATA.0$A <- 0
    
    fit.pred1 <- predictCox(fitS, newdata=DATA.1, times=Y.grid , type = "survival")
    fit.pred0 <- predictCox(fitS, newdata=DATA.0, times=Y.grid , type = "survival")
    S_hat1 <- fit.pred1$survival
    S_hat0 <- fit.pred0$survival
    
    if ( length(Y.grid) > 1){
      S_hat0[,length(Y.grid)] <- S_hat0[,length(Y.grid)-1]
      S_hat1[,length(Y.grid)] <- S_hat1[,length(Y.grid)-1]
      }
    }
  # if (type_of_model == "kaplan_meier"){
  #   DATA1 <- DATA %>%
  #     dplyr::filter(A==1)
  #   DATA0 <- DATA %>%
  #     dplyr::filter(A==0)
  #   KM1 <-Kaplan_meier_handmade(DATA1,DATA1$status,DATA1$T_obs)
  #   KM0 <- Kaplan_meier_handmade(DATA0,DATA0$status,DATA0$T_obs)
  #   S_hat1 <- KM1$S
  #   S_hat0 <- KM0$S
  # }
S_hat <- S_hat1*DATA$A + (1-DATA$A)*S_hat0
return(list('S_hat'=S_hat,"S_hat1"=S_hat1,"S_hat0"=S_hat0,"T"=Y.grid))
}

#S_C_hat <-estimate_survival_function(data,c("X1","X2","X3"),Y.grid,T_obs="T_obs_tau",status="censor.status_tau")
#plot(S_C_hat$T,S_C_hat$S_hat[1,])
#status_tau_t <- sapply(Y.grid,function(t) as.numeric((data$T_obs>=t) | (data$T_obs<t &  data$status == 1 )))
#weights <- status_tau_t/S_C_hat$S_hat
#S <- Kaplan_meier_handmade_w(data,T_obs=data$T_obs,status=data$status, weights = weights)
#Sbis <- Kaplan_meier_handmade(data,T_obs=data$T_obs,status=data$status)

# plot des deux courbes
#plot(S$T,S$S)+
#  lines(Sbis$T,Sbis$S)


# IPCW kaplan meier estimator with restricted tau
# fit IPCW KM 
# Y.grid = sort(unique(data$T_obs))
IPCW_Kaplan_meier <- function(data,tau){
  data$T_obs_tau <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$censor.status_tau <- 1- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$status_tau <- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_C_hat <-estimate_survival_function(data,c("X1","X2","X3","X4"),Y.grid,T_obs="T_obs_tau",status="censor.status_tau")
  
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data),match(data$T_obs_tau,Y.grid))]
  
  data$weights <- data$status_tau/data$S_C

  DATA_treated <- data[data$A == 1,]
  DATA_not_treated <- data[data$A == 0,]

  S <- adjusted.KM(times=data$T_obs_tau,failures=data$status_tau, variable=data$A ,weights = data$weights)

  
  #Exact same results : 
  RMST <- RMST_fromS(S_A1=S[S$variable==1,],S_A0=S[S$variable==0,],tau=tau)
  
  return(list(RMST = RMST$RMST, ATE_treated = RMST$intA1, ATE_not_treated = RMST$intA0))
}
```

Based on the identifiability formula @eq-RMSTipcw, it is possible to implement the IPCW estimator differently not in using the survival function.



```{r}
# other way of implementing IPCW
IPCW_min <- function(data,tau){
  data$T_obs_tau <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$censor.status_tau <- 1- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$status_tau <- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  Y.grid<- sort(unique(data$T_obs_tau))
  
  S_C_hat <-estimate_survival_function(data,c("X1","X2","X3","X4"),Y.grid,T_obs="T_obs_tau",status="censor.status_tau")
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data),match(data$T_obs_tau,Y.grid))]
  
  data$weights <- data$status_tau/data$S_C
  
  DATA_treated <- data[data$A == 1,]
  DATA_not_treated <- data[data$A == 0,]

  DATA_treated$RST <- DATA_treated$T_obs_tau*DATA_treated$weights
  DATA_not_treated$RST <- DATA_not_treated$T_obs_tau*DATA_not_treated$weights
  
  RMST <- mean(DATA_treated$RST) - mean(DATA_not_treated$RST)
  return(list(RMST = RMST, ATE_treated = mean(DATA_treated$RST), ATE_not_treated = mean(DATA_not_treated$RST)))
}

#same graph
# graph de l'evolution des RMST en fonction de tau pour IPCW_min et IPCW_Kaplan_meier
#tau <- seq(1,50,by=1)
#RMST_min <- sapply(tau,function(t) IPCW_min(data,tau=t)$RMST)
#RMST_Kaplan <- sapply(tau,function(t) IPCW_Kaplan_meier(data,tau=t)$RMST)

#plot(tau,RMST_min,type="l",col="red",xlab="tau",ylab="RMST",main="RMST en fonction de tau")
#lines(tau,RMST_Kaplan,type="l",col="blue")


```

# Causal survival analysis with an observational study

In the context of observational study, @eq-randomization (randomized
treatment assignment) is no longer verified. Some additional assumptions
are required to identify $\theta_{RMST}$. These assumptions are
classical for causal inference with observational data:

::: assumption
**Assumption 5:Conditional exchangeability / Uncounfoundedness**

$$ 
 A \perp\mkern-9.5mu\perp(T(0),T(1)) | X
$$ {#eq-uncounf} with $X$ the set of covariates that are related both to
treatment's assignment and outcomes.
:::

Under Assumption @eq-uncounf, the treatment assignment is randomly
assigned conditionally on the covariates $X$. It is as if the treatment
for all subjects were randomly selected inside each subgroup.

::: assumption
**Assumption 6:Positivity / Overlap for treatment**

$$ 
1 > P(A=a \mid X=x)>0
$$ {#eq-positivitytreat} with $X$ the set of covariates that are related
both to treatment's assignment and outcomes.
:::

**Indentifiability**

Under @eq-uncounf (Uncounfoundedness) and @eq-independantcensoring
(Independent censoring), the RMST can be identified as follows:

$$
\begin{aligned}
    \theta & =\mathbb{E}[T(1) \wedge \tau-T(0) \wedge \tau] \\
    &= \mathbb{E}[T(1) \wedge \tau]-\mathbb{E}[T(0) \wedge \tau] \tiny\text {(By linearity) }  \\
    &= \mathbb{E}\left[\mathbb{E}[T(1) \wedge \tau \mid X]\right]-\mathbb{E}[T(0) \wedge \tau \mid X] \tiny\text { (By the total probability law) }  \\
    &= \mathbb{E}\left[\frac{\mathbb{E}\left[T(1) \wedge \tau|X\right]*\mathbb{E}[A|X]}{e(X)}-\frac{\mathbb{E}[T(0) \wedge \tau|X]*\mathbb{E}[1-A|X]}{1-e(X)}\right] \\
    &= \mathbb{E}\left[\frac{\mathbb{E}\left[A*T(1) \wedge \tau|X\right]}{e(X)}-\frac{\mathbb{E}[(1-A)T(0) \wedge \tau|X]}{1-e(X)}\right] \tiny\text { (By unconfoundedness) }\\
    & =\mathbb{E}\left[\mathbb{E}[(T \wedge \tau) \mid A, X]\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)}\right)\right] \tiny\text { (By consistency) }\\
    &= \int_0^\tau \mathbb{E}\left[1(\{T \geq t\}|A) \right]*\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)}\right) dt \\
    &= \int_0^\tau p(T \geq t | A)*\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)}\right) dt 
\end{aligned}
$$ {#eq-RMST-IPTW}

Under @eq-uncounf (Uncounfoundedness) and @eq-condindepcensoring
(conditionally independent censoring), the RMST can be identified as
follows:

$$
\begin{aligned}
    \theta & =\mathbb{E}[T(1) \wedge \tau-T(0) \wedge \tau] \\
    &= \mathbb{E}[T(1) \wedge \tau]-\mathbb{E}[T(0) \wedge \tau] \tiny\text {(By linearity) }  \\
    &= \mathbb{E}\left[\mathbb{E}[T(1) \wedge \tau \mid X]\right]-\mathbb{E}[T(0) \wedge \tau \mid X] \tiny\text { (By the total probability law) }  \\
    & =\mathbb{E}\left[\mathbb{E}[(T \wedge \tau) \mid A, X]\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)}\right)\right] \tiny\text { (def of IPTW) }  \\
    & =\mathbb{E}\left[\frac{\widetilde{T} \wedge \tau \cdot \Delta^\tau}{S_C(\widetilde{T} \wedge \tau \mid A, X)}\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)}\right) \right]  \tiny\text { (def of IPCW) } &&
    
\end{aligned}
$$ {#eq-RMST-IPTW-IPCW}

Under the same assumptions, it can be identified also as g-formula:

$$
\begin{aligned}
    \theta & =\mathbb{E}\left[T(1) \wedge \tau-T(0) \wedge \tau\right] \\
    & =\mathbb{E}\left[\mathbb{E}\left[T(1) \wedge \tau-T(0) \wedge \tau \mid X\right]\right] \\
    & =\mathbb{E}\left[\mathbb{E}\left[T(1) \wedge \tau \mid X, A=1\right]-\mathbb{E}\left[T(0) \wedge \tau \mid X=X, A=0\right]\right] \tiny\text { (Uncounfoundedness) } \\
    & =\mathbb{E}\left[\mathbb{E}\left[T \wedge \tau \mid X, A=1\right]-\mathbb{E}\left[T \wedge \tau \mid X, A=0\right]\right] \tiny\text { (Consistency) }
\end{aligned}
$$ {#eq-RMST-gformula}

## Estimation under independent censoring

### IPTW Kaplan Meier estimator

Under Uncounfoundedness and independent censoring @eq-uncounf and
@eq-independantcensoring, the Kaplan Meier estimator has to include a
weighting term to take into account that the treated and control groups
are unbalanced. This weighted estimator is called the inverse
probability of treatment weighted Kaplan Meier estimator (IPTW-KM)
[@IPTW].

Based on the identifiability @eq-RMST-IPTW, the IPTW KM is defined as:

::: {#def-iptwkm}
#### Adjusted IPTW kaplan meier estimator

$$\hat{S}_{IPTW-KM}(t \mid a) = \prod_{j=1, t_j<=t}\left(1-\frac{\sum_i \hat{w_{i}}*I\left\{T_i=t_j, C_i \geq t_j, A_i=a\right\}}{\sum_i \hat{w_{i}}*I\left\{T_i \geq t_j, C_i \geq t_j, A_i=a\right\}}\right)$$

with
$\hat{w_{i}}=\frac{A_{i}}{\hat{e}(X_{i})}+ \frac{1-A_{i}}{1-\hat{e}(X_{i})}$
the inverse of the propensity score.
:::

In the exact same way than before, the corresponding RMST is obtained in
integrating from 0 to $\tau$ the difference between IPTW adjusted kaplan
meier estimator of the treated and controls @eq-RMST-IPTW.

**Implementation**

```{r}

library(grf)
estimate_propensity_score <- function(DATA,treatment_covariates,type_of_model="reglog"){
  # ## GLM
  if (type_of_model == "reglog"){
    outcome <- 'A'
    f <- as.formula(paste(outcome, paste(c(treatment_covariates), collapse = " + "), sep = " ~ "))
    fitA <- glm(f,data = DATA,family = binomial(link="logit"))
    e_hat <- predict(fitA,newdata=DATA,type="response")
    return(e_hat)
  }
  if (type_of_model == "forest"){
    
    # onehot encode factor variables
    categorical_name <- names(which(sapply(subset(DATA, select = c(treatment_covariates)), class) == "factor"))
    if (length(categorical_name) >0){
      numerical_name <- setdiff(treatment_covariates,categorical_name)
      na.action <- options()$na.action
      options(na.action='na.pass')
      X_one_hot <- model.matrix(~ 0 + ., DATA[categorical_name], na.action = "na.pass")
      categorical_name_one_hot <- names(as.data.frame(X_one_hot))
      replace_string <- function(string) {return(str_replace_all(string, ' ', '_'))}
      categorical_name_one_hot <- sapply(categorical_name_one_hot,replace_string)
      DATA[categorical_name_one_hot] <- X_one_hot
      treatment_covariates<- union(categorical_name_one_hot,numerical_name)
      options(na.action = na.action)
    }
    ## Forest
    
    Xipw <- as.matrix(DATA[treatment_covariates])
    Wipw <- as.matrix(DATA$A)
    forest.W <- regression_forest(Xipw, Wipw,honesty = FALSE)
    e_hat <- predict(forest.W)$predictions
    return(e_hat)
  }
}

IPTW_Kaplan_Meier<- function(data,tau){
  data$e_hat <- estimate_propensity_score(data,treatment_covariates = c("X1","X2","X3","X4"))
  data$T_obs_tau <- pmin(data$T_obs, tau)
  data$status_tau <- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$weights <- (data$A) * (1/data$e_hat) + (1-data$A)/(1-data$e_hat)
  
  S <- adjusted.KM(times=data$T_obs_tau,failures=data$status_tau, variable=data$A ,weights = data$weights)
  RMST <- RMST_fromS(S_A1=S[S$variable==1,],S_A0=S[S$variable==0,],tau=tau)
  
  return(list("intA0"=RMST$intA0,"intA1"=RMST$intA1,"RMST"=RMST$RMST))
}


#IPTW_Kaplan_Meier(data,e_hat,tau)


```

As $T \wedge \tau$ is not directly observable because of censoring, we have to use a censoring unbiased
transformation to identify $E [(T \wedge \tau )|A, X]$



## Estimation under conditionally independent censoring

### Inverse probability of weighting estimation (IPTW-IPCW)

When the independent censoring assumption is not verified, the IPTW-IPCW
Kaplan meier estimator can be used to estimate the causal treatment
effect. The IPTW-IPCW KM estimator is a combination of both estimators
[@Doubleweight]: IPTW to overcome that the treatment allocation is not
random and IPCW to overcome the dependent censoring.

Based on the identifiability @eq-RMST-IPTW-IPCW, the IPTW-IPCW is
defined as:

::: {#def-iptwipcw}
#### IPTW-IPCW estimator

$$\widehat{\theta}_{\mathrm{IPTW}-\mathrm{IPCW}}(\tau) = \frac{1}{n} \sum_{i=1}^n \frac{\Delta_i^\tau \cdot \tilde{T}_i \wedge \tau}{\hat{S}_C\left(\widetilde{T} \wedge \tau \mid A_i, X_i\right)}\left(\frac{A_i}{\hat{e}\left(X_i\right)}-\frac{1-A_i}{1-\hat{e}\left(X_i\right)}\right) $$

where $\hat{S}_C\left(\widetilde{T} \wedge \tau \mid A_i, X_i\right)$ is
a semi parametric (or parametric) methodology to estimate the survival
function of remain uncensored.
:::

It enables a balance between treatment and control groups and between
censored and uncensored individuals.

This RMST estimator can be obtained at first in estimating the survival
function of remain uncensored in using semi-parametric or parametric
model. Then, the weight for each observation can be computed as:

$$w_i=\frac{\Delta_i^\tau}{\hat{S}_C\left(\widetilde{T} \wedge \tau \mid A_i, X_i\right)}*(\frac{A_i}{\hat{e}\left(X_i\right)}-\frac{1-A_i}{1-\hat{e}(X_i)})$$

An adjusted kaplan estimator (weighted by the previous $w_i$) can be
fitted for $A=1$ and $A=0$ (see definition @def-iptwipcw):
$$
     \theta_{RMST}(\tau) = \int_{0}^{\tau}\left( S_1(t) - S_0(t) \right)dt
$$

::: {#def-iptwipcwkm}
#### Adjusted IPTW-IPCW kaplan meier estimator

$$\hat{S}_{IPTW-IPCW-KM}(t \mid a) = \prod_{j=1, t_j<=t}\left(1-\frac{\sum_i \hat{w_{i}}(t,X_i)*I\left\{T_i=t_j, C_i \geq t_j, A_i=a\right\}}{\sum_i \hat{w_{i}}(t,X_i)*I\left\{T_i \geq t_j, C_i \geq t_j, A_i=a\right\}}\right)$$

with
$\hat{w_{i}}(t,X_i)=\frac{1}{\hat{S}_C\left(\widetilde{T} \wedge \tau \mid A_i, X_i\right)}*(\frac{A_{i}}{\hat{e}(X_{i})}+ \frac{1-A_{i}}{1-\hat{e}(X_{i})})$
the corresponding weight including the inverse of the propensity score
and the inverse probability of remain uncensored given the covariates.
:::

Then, the corresponding RMST is the integral of the difference between
the survival curve with $A=1$ and the $A=0$.

**Implementation**

```{r} 
IPTW_IPCW_Kaplan_Meier<- function(data,tau){
  data$T_obs_tau <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$censor.status_tau <- 1- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$status_tau <- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$e_hat <- estimate_propensity_score(data,treatment_covariates = c("X1","X2","X3","X4"))
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_C_hat <-estimate_survival_function(data,c("X1","X2","X3","X4"),Y.grid,T_obs="T_obs_tau",status="censor.status_tau")
  
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data),match(data$T_obs_tau,Y.grid))]
  
  data$weights <- data$status_tau/data$S_C*((data$A) * (1/data$e_hat) + (1-data$A)/(1-data$e_hat))

  DATA_treated <- data[data$A == 1,]
  DATA_not_treated <- data[data$A == 0,]

  S <- adjusted.KM(times=data$T_obs_tau,failures=data$status_tau, variable=data$A ,weights = data$weights)

  
  #Exact same results : 
  RMST <- RMST_fromS(S_A1=S[S$variable==1,],S_A0=S[S$variable==0,],tau=tau)
  
  return(list(RMST = RMST$RMST, ATE_treated = RMST$intA1, ATE_not_treated = RMST$intA0))
}
  
#IPTW_IPCW_Kaplan_Meier(data,e_hat,tau)

```

Exactly the same than IPCW estimator, it exists another way of implementing the IPCW-IPTW estimator :
**(pas les mêmes resultats)**

```{r}
# In using the min
IPTW_IPCW_min<- function(data,e_hat,tau){
  data$T_obs_tau <- ifelse(data$T_obs>=tau,tau,data$T_obs)
  data$censor.status_tau <- 1- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$status_tau <- as.numeric((data$T_obs>=tau) | (data$T_obs<tau &  data$status == 1 ))
  data$e_hat <- estimate_propensity_score(data,treatment_covariates = c("X1","X2","X3","X4"))
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_C_hat <-estimate_survival_function(data,c("X1","X2","X3","X4"),Y.grid,T_obs="T_obs_tau",status="censor.status_tau")
  
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data),match(data$T_obs_tau,Y.grid))]
  
  data$weights <- data$status_tau/data$S_C*((data$A/data$e_hat) + (1-data$A)/(1-data$e_hat))
  data$RST <- data$T_obs_tau*data$weights
  
  DATA_treated <- data[data$A == 1,]
  DATA_not_treated <- data[data$A == 0,]
  
  RMST <- mean(DATA_treated$RST) - mean(DATA_not_treated$RST)
  return(list(RMST = RMST, ATE_treated = mean(DATA_treated$RST), ATE_not_treated = mean(DATA_not_treated$RST)))
}

```



### G-formula plug-in estimator

Another possible estimator under @eq-uncounf and @eq-condindepcensoring
is the G-formula plug-in estimator.

It is an alternative of IPCW in leveraging the regression formulation.
Instead of fitting a model for the censored mechanism and a model for
the probability of being treated, the corresponding estimators fit a
model of the conditional outcome mean. Applying these models to the each
treatment arm, and then marginalizing over the empirical covariates
distributions of the target population, gives the corresponding expected
outcome [@ROBINS1986]. Based on the g-formula identifiability
@eq-RMST-gformula}, this outcome model based estimator is defined as:

::: {#def-gformula}
#### G-formula plug-in estimator

$$ \widehat{\theta}_{\text {g-formula }}(\tau) =\frac{1}{n} \sum_{i=1}^n\left(\hat{F}\left(X_i, 1\right)-\hat{F}\left(X_i, 0\right)\right) $$

with $F(x, a) \triangleq \mathbb{E}[T \wedge \tau \mid X=x, A=a]$. It
can be estimated in using semi-parametric or parametric methods.
:::

Generally, $F(x, a)$ estimator is based on the estimation of the
conditional survival function. It can be obtained in fitting one
semi-parametric (or parametric) model (i.e. Cox model) by treatment on
the corresponding observations and in predicting the results for the all
observations. Then, the RMST is computed by the integral of the
difference between the predicted conditional survival curve with A=1 and
A=0.

**Implementation**

```{r}
library(dplyr)
library(rms)
library(survival)

# compute the area under the survival curve for each individual :  Trapezoidal rule
# S.hat : predicted survival function for each individual 
expected_survival <- function(S.hat, Y.grid) {
  # Y.grid : vector of time at which to evaluate the survival estimates (same than S.hat)
  # grid.diff : distance between each timepoint
  grid.diff <- diff(c(0, Y.grid, max(Y.grid)))
  # area under each survival curve
  c(base::cbind(1, S.hat) %*% grid.diff)
}

g_formula_cox_T_learner <- function(DATA,X_outcome,Y.grid) {
  outcome <- 'Surv(T_obs,status)'
  # learn cox regression on two dataset : A|X
  # A == 0
  DATA0 <- DATA %>% filter(A == 0)
  # A == 1
  DATA1 <- DATA %>% filter(A == 1)
  
  # formula T ~ X_outcome
  f <- as.formula(paste(outcome, paste(c(X_outcome), collapse = " + "), sep = " ~ "))
  # fit the two models on the vector of time Y.grid 
  fitS0 <- cph(f,data=DATA0,y=TRUE,x=TRUE,times = Y.grid)
  fitS1 <- cph(f,data=DATA1,y=TRUE,x=TRUE,times = Y.grid)
  
  # predict to all the dataset set to A=1
  DATA.1 <- DATA
  DATA.1$A <- 1

  # predict to all the dataset se to A=0
  DATA.0 <- DATA
  DATA.0$A <- 0
  
  # predict on Y.grid each individual
  fit.pred1 <- predictCox(fitS1, newdata=DATA.1, times=Y.grid , type = "survival")
  fit.pred0 <- predictCox(fitS0, newdata=DATA.0, times=Y.grid , type = "survival")
  # survival probability for each individual at each Y.grid
  S_hat1 <- fit.pred1$survival
  S_hat0 <- fit.pred0$survival

  # area under each survival curve until max(Y.grid)=tau 
  # A =1
  E_hat1 <- expected_survival(S_hat1,Y.grid)
  # A =0
  E_hat0 <- expected_survival(S_hat0,Y.grid)
  
  # mean difference 
  theta_g_formula <- mean(E_hat1 - E_hat0)
  return(theta_g_formula)
}
```

### RMST Packages

```{r}
library(survRM2)
RMST_package <- function(data, tau) {
  x1 <- max(data$T_obs[data$A == 1])  # Maximum observed time in Group 1
  x0 <- max(data$T_obs[data$A == 0])  # Maximum observed time in Group 0
  
  last_event_1 <- max(data$T_obs[data$A == 1 & data$status == 1])  # Last event in Group 1
  last_event_0 <- max(data$T_obs[data$A == 0 & data$status == 1])  # Last event in Group 0
  
  last_censor_1 <- max(data$T_obs[data$A == 1 & data$status == 0]) # Last censor in Group 1
  last_censor_0 <- max(data$T_obs[data$A == 0 & data$status == 0]) # Last censor in Group 0
  
  # Determine the cases
  
  if (last_event_1 == x1 && last_event_0 == x0) { # Case 1
    if(tau > max(x1, x0)) {
      tau <- max(x1, x0)
    }
  } else if (last_event_1 == x1 && last_event_0 != x0 && x1 <= x0) { # Case 2-1
    if (tau>x0){
      tau <- x0
    } 
  } else if (last_event_1 == x1 && last_event_0 != x0 && x1 > x0) { # Case 2-2
    if (tau>x1){
      tau <- x1
      }
  } else if (last_event_1 != x1 && last_event_0 == x0 && x1 > x0) { # Case 3-1
    if (tau>x0){
      tau <- x0
    } 
  } else if (last_event_1 != x1 && last_event_0 == x0 && x1 <= x0) { # Case 3-2
    if (tau>x1){
      tau <- x1
    } 
  } else if (last_event_1 != x1 && last_event_0 != x0) { # Case 4
    if(tau > min(x1, x0)) {
      tau <- min(x1, x0)
    }
  } else {
    tau <-tau
  }
  
  ATE_pack <- rmst2(data$T_obs, data$status, arm = data$A, tau = tau)
  
  RMST <- ATE_pack[[5]][1]
  
  return(RMST)
}

  
#test <- RMST_package(data_rct1,tau=20)
#test  
```

```{r}
# in using the package survival 

library(survival)

# function to compute the RMST

```


# Simulation {#sec-simulation}

## RCT

We conducted two simples simulations to simulate RCTs studies, baseline
covariates with no time dependency. The first simulation represents a
scenario with independent censoring and the second one with conditional
dependent censoring.

The time of event and the censoring time (when there is dependency
between the censoring time and the covariates) is simulated using the
cumulative hazard method for exponential models using the *simsurv* R
package.

For the simulation, 2000 samples $(X_{i},A_{i},C,T_{i}(0), T_{i}(1))$
are generated in the following way :

-   $X \sim \mathcal{N}\left(\mu=[1,1,-1,1]^{\top}, \Sigma=I_4\right)$

-   $e(X)=0.5$ (constant) for the propensity score $(A)$

-   $\lambda(0)(X)=0.1 \cdot \exp \left\{0.5 X_1-0.1 X_2+0.3 X_3+0.2 X_4\right\}$
    hazard for the event time $T(0)$

-   The hazard for the censoring time $C$:

    -   For scenario 1 :
        $\lambda_c(X)=0.03 \cdot \exp \left\{0.1 X_1+0.1 X_2-0.2 X_3-0.2 X_4\right\}$.

    -   For scenario 2 : $\lambda_c=0.03$.

-   $T(1)=T(0)+15$

-   the event time is $T=A T(1)+(1-A) T(0)$

-   The observed time is $\widetilde{T}=\min (T, C)$

-   The status is $\Delta=1(T \leq C)$

(- The threshold time $\tau$ is 20)

The observed samples are $(X_{i},A_{i},\Delta_{i},\widetilde{T_{i}})$
represented in Table @tbl-exemple_data_rct.

The cumulative hazard inversion method is explained in annexes
@sec-Annexes.

```{r setup rct}
# scenario :
############ RCT 
# RCT1 : Random treatment assignment + independent censoring
# RCT2 : Random treatment assignment + dependent censoring (conditional on X)

simulate_data_RCT <- function(n,mu= c(1, 1, -1, 1), sigma=diag(4),tau,coefT0=0.01,
parsS=c(0.5,0.5,-0.5,0.5),coefC=0.03,parsC=c(0.1,0.1,-0.2,-0.2),scenario="RCT2"){
  if (scenario=="RCT1"){
    # Generate X from multivariate normal distribution
    X <- MASS::mvrnorm(n, mu, sigma)
    X <- as.data.frame(X)
    colnames(X) <- c("X1", "X2", "X3", "X4")
    #head(X)
    # Treatment variable selection : all X
    X_treatment<- as.matrix(X)
    # propensity score constant : random assignment for each patient
    
    e <- as.numeric(rep(0.5,n))
    
    #e <- 0.5
    
    # Random treatment assignment
    A <- sapply(e, FUN=function(p) rbinom(n=1, size=1, prob=p))
    
    # Outcome variable selection : all X 
    X_outcome<- as.matrix(X)
    
    # Simulate the outcome  with the cumulative hazard inversion method because T depends on X even in RCT
    epsilon <- runif(n, min = 0.00000001, max = 1)
    T0 <- -log(epsilon)/(coefT0*exp(  X_outcome%*% parsS ))
    
    #lambda = coefC for the independent censoring time 
    epsilon <- runif(n, min = 0.00000001, max = 1)
    C <- -log(epsilon)/coefC
    
    # Temps T(1) = T(0) + 4
    T1 <- T0 + 4
    
    
    T_true <- A*T1 + (1-A)*T0
  
    # Observed time
    T_obs <- pmin(T_true, C)

    # Status
    status <- as.numeric(T_true <= C)
    censor.status <- as.numeric(T_true > C)

    # Restricted survival time
    T_obs_tau <- pmin(T_obs,tau)
    status_tau <- as.numeric((T_obs>tau) | (T_obs<=tau &  status == 1 ))
  }
  if (scenario=="RCT2"){
    # Generate X from multivariate normal distribution
    X <- MASS::mvrnorm(n, mu, sigma)
    X <- as.data.frame(X)
    colnames(X) <- c("X1", "X2", "X3", "X4")
    #head(X)
    # Treatment variable selection : all X
    X_treatment<- as.matrix(X)
    # propensity score constant : random assignment 
    e <- as.numeric(rep(0.5,n))
    
    
    # Random treatment assignment
    A <- sapply(e, FUN=function(p) rbinom(n=1, size=1, prob=p))
    
    # Outcome variable selection : all X 
    X_outcome<- as.matrix(X)
    
    # Simulate the outcome  with the cumulative hazard inversion method because T depends on X even in RCT
    epsilon <- runif(n, min = 0.00000001, max = 1)
    T0 <- -log(epsilon)/(coefT0*exp(  X_outcome%*% parsS ))
    
    X_censoring<- as.matrix(X)
    #lambda = coefC for the independent censoring time 
    epsilon <- runif(n, min = 0.00000001, max = 1)
    C <- -log(epsilon)/(coefC*exp(rowSums(X_censoring %*% diag(parsC))))
    
    
    # Temps T(1) = T(0) + 4
    T1 <- T0 + 4
    
    
    T_true <- A*T1 + (1-A)*T0
  
    # Observed time
    T_obs <- pmin(T_true, C)

    # Status
    status <- as.numeric(T_true <= C)
    censor.status <- as.numeric(T_true > C)

    # Restricted survival time
    T_obs_tau <- pmin(T_obs,tau)
    status_tau <- as.numeric((T_obs>tau) | (T_obs<=tau &  status == 1 ))
  }
    DATA_target_population <- data.frame(X,tau,A,T0,T1,C,T_obs,T_obs_tau, status,censor.status,status_tau,e)
  
  return(DATA_target_population)
}


```

```{r}
library(shiny)
library(tidyverse)
library(survminer)

# Définition de l'interface utilisateur
ui <- fluidPage(
  titlePanel("Exploration des données de survie"),
  
  sidebarLayout(
    sidebarPanel(
      sliderInput("coefT0", "Coefficient T0", min = 0.01, max = 0.5, value = 0.1, step = 0.01),
      sliderInput("coefC", "Coefficient C", min = 0.01, max = 0.5, value = 0.03, step = 0.01),
      numericInput("tau", "Valeur de tau", value = 20)
    ),
    mainPanel(
      plotOutput("survival_plot1"),
      plotOutput("survival_plot2")
    )
  )
)

# Définition du serveur
server <- function(input, output) {
  output$survival_plot1 <- renderPlot({
    data <- simulate_data_RCT(1000, tau = input$tau, coefT0 = input$coefT0, coefC = input$coefC,scenario="RCT1")
    A<- data$A
    surv_fit <- survfit(Surv(time = data$T_obs_tau, event = data$status_tau) ~ data$A)
    
    # Tracé de la première courbe de survie
    ggsurvplot(surv_fit, data=data,
      surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
      conf.int = TRUE,             # Affiche les intervalles de confiance
      risk.table = TRUE,           # Affiche le tableau des risques en bas du graphique
      risk.table.title = "Risks",  # Titre du tableau des risques
      title = "Survival curve",  # Titre du graphique
      xlab = "Time (days)",        # Étiquette de l'axe x
      ylab = "Survival Probability" # Étiquette de l'axe y
    )
  })
  
  output$survival_plot2 <- renderPlot({
    data <- simulate_data_RCT(1000, tau = input$tau, coefT0 = input$coefT0, coefC = input$coefC,scenario="RCT1")
    
    # Tracé de la deuxième courbe de survie
    cens_fit <- survfit(Surv(time = data$T_obs, event = data$censor.status) ~ data$A)
    ggsurvplot(cens_fit, data=data,
      surv.median.line = "hv",
      conf.int = TRUE,
      title = "Probability of remain uncensored",
      xlab = "Time (days)",
      ylab = "Censoring Probability",
      xlim=c(0,100)
    )
  })
}

# Exécuter l'application
shinyApp(ui = ui, server = server)

```

```{r}

# Interface utilisateur
ui2 <- fluidPage(
  titlePanel("Exploration des données de survie"),
  #textOutput("text"),
  paste("Rappel : T0 est calculer à partir de la formule T0 = -log(U)/(coefT0*exp(X%*%parsS)) où U suit une loi uniforme sur [0,1].",
  "Les coefficients a,b,c et d sont les coefficients de la matrice X. Les covariables X sont générées aléatoirement à partir d'une loi normale réduite de moyenne : mu = c(1,1,-1,1) . Les paramètres de la simulation peuvent être modifiés à l'aide des curseurs ci-dessous."),
  sidebarLayout(
    sidebarPanel(
      sliderInput("coefT0", "Coefficient T0", min = 0.01, max = 0.5, value = 0.1, step = 0.01),
      sliderInput("a", "Valeur de a", min = -5, max = 5, value = 1, step=0.5),
      sliderInput("b", "Valeur de b", min = -5, max = 5, value = 1, step=0.5),
      sliderInput("c", "Valeur de c", min = -5, max = 5, value = -1, step=0.5),
      sliderInput("d", "Valeur de d", min = -5, max = 5, value = 1, step=0.5)
    ),
    mainPanel(
      plotOutput("density_plot")
    )
  )
)

# Serveur
server2 <- function(input, output) {
  output$text <- renderText({
    paste("Les paramètres de la simulation sont :",
          "coefT0 =", input$coefT0,
          "a =", input$a,
          "b =", input$b,
          "c =", input$c,
          "d =", input$d)
  })
  output$density_plot <- renderPlot({
    # Générer les données de survie
    data <- simulate_data_RCT(1000, tau = 20, coefT0 = input$coefT0, parsS = c(input$a, input$b, input$c, input$d),scenario="RCT1")
    
    # Tracer les densités de T0 et T1
    dens_T0 <- density(data$T0)
    dens_T1 <- density(data$T1)
    
    plot(dens_T0, main = "Densité de T0 et T1", xlim = c(0, max(dens_T0$x, dens_T1$x)), ylim = c(0, max(dens_T0$y, dens_T1$y)))
    lines(dens_T1, col = "red")
    legend("topright", legend = c("T0", "T1"), col = c("black", "red"), lty = 1)
  })
}

# Exécuter l'application
shinyApp(ui = ui2, server = server2)
```

```{r}
data_rct1 <- simulate_data_RCT(n=2000,tau=70,scenario="RCT1")
  
data_rct2 <- simulate_data_RCT(n=2000,tau=5,scenario="RCT2")

```

## Observationnal study

We conducted two simples simulations to simulate observationnal studies
with a static treatment assignment, baseline covariates with no time
dependency. The first simulation represents a scenario with independent
censoring and the second one with conditional dependent censoring.

The time of event and the censoring time (when there is dependency
between the censoring time and the covariates) is simulated using the
cumulative hazard method for exponential models using the *simsurv* R
package.

For the simulation, 2000 samples $(X_{i},A_{i},C,T_{i}(0), T_{i}(1))$
are generated in the following way :

-   $X \sim \mathcal{N}\left(\mu=[1,1,-1,1]^{\top}, \Sigma=I_4\right)$

-   $\operatorname{logit}\{e(X)\}=-0.5 X_1-0.3 X_2+0.1 X_3+0.2 X_4$ for
    the propensity score $(A)$

-   $\lambda(0)(X)=0.1 \cdot \exp \left\{0.5 X_1-0.1 X_2+0.3 X_3+0.2 X_4\right\}$
    hazard for the event time $T(0)$

-   The hazard for the censoring time $C$:

    -   For scenario 1 :
        $\lambda_c(X)=0.03 \cdot \exp \left\{0.1 X_1+0.1 X_2-0.2 X_3-0.2 X_4\right\}$.

    -   For scenario 2 : $\lambda_c=0.03$.

-   $T(1)=T(0)+4$

-   the event time is $T=A T(1)+(1-A) T(0)$

-   The observed time is $\widetilde{T}=\min (T, C)$

-   The status is $\Delta=1(T \leq C)$

(- The threshold time $\tau$ is 20)

The observed samples are $(X_{i},A_{i},\Delta_{i},\widetilde{T_{i}})$
represented in Table @tbl-exemple_data.

```{r setup obs}
library(simsurv)
library(survival)

# simulate data 
############ Observational 
# Obs1 : Treatment assignment dependent on X + independent censoring
# Obs2 : Treatment assignment dependent on X + dependent censoring (conditional on X)


simulate_data_obs <- function(n,mu= c(1, 1, -1, 1), sigma=diag(4),tau,coefT0=0.1,
parsS=c(0.5,-0.1,0.3,0.2),parsA=c(-0.5,-0.3,0.1,0.2),coefC=0.03,parsC=c(0.1,0.1,-0.2,-0.2),scenario="Obs2"){
  if (scenario =="Obs1"){
    # Generate X from multivariate normal distribution
    X <- MASS::mvrnorm(n, mu, sigma)
    X <- as.data.frame(X)
    colnames(X) <- c("X1", "X2", "X3", "X4")
    #head(X)
    # Treatment variable selection : all X
    X_treatment<- as.matrix(X)
    # propensity score
    e <- rowSums(as.matrix(X_treatment) %*% diag(parsA))
    e <- plogis(e)
    
    # Affectation de traitement
    A <- sapply(e, FUN=function(p) rbinom(n=1, size=1, prob=p))
    
    # Outcome variable selection : all X 
    X_outcome<- as.matrix(X)
    
    # Simulate the outcome  with the cumulative hazard inversion method 
    epsilon <- runif(n, min = 0.00000001, max = 1)
    T0 <- -log(epsilon)/(coefT0*exp(  X_outcome%*% parsS ))
    
    #lambda = coefC
    epsilon <- runif(n, min = 0.00000001, max = 1)
    C <- -log(epsilon)/(coefC)
    
    # Temps T(1) = T(0) + 4
    T1 <- T0 + 4
    
    
    T_true <- A*T1 + (1-A)*T0
  
    # Observed time
    T_obs <- pmin(T_true, C)

    # Status
    status <- as.numeric(T_true <= C)
    censor.status <- as.numeric(T_true > C)

    # Restricted survival time
    T_obs_tau <- pmin(T_obs,tau)
    status_tau <- as.numeric((T_obs>tau) | (T_obs<=tau &  status == 1 ))
  }
  if (scenario=="Obs2"){
    # Generate X from multivariate normal distribution
    X <- MASS::mvrnorm(n, mu, sigma)
    X <- as.data.frame(X)
    colnames(X) <- c("X1", "X2", "X3", "X4")
    #head(X)
    # Treatment variable selection : all X
    X_treatment<- as.matrix(X)
    # propensity score
    e <- rowSums(as.matrix(X_treatment) %*% diag(parsA))
    e <- plogis(e)
    
    # Affectation de traitement
    A <- sapply(e, FUN=function(p) rbinom(n=1, size=1, prob=p))
    
    # Outcome variable selection : all X 
    X_outcome<- as.matrix(X)
    # Simulate the outcome  with the cumulative hazard inversion method 
    epsilon <- runif(n, min = 0.00000001, max = 1)
    T0 <- -log(epsilon)/(coefT0*exp(  X_outcome%*% parsS ))
    
    # Temps T(1) = T(0) + 4
    T1 <- T0 + 4
    
    # Selection between T0 and T1
    T_true <- A*T1 + (1-A)*T0
    
    # Censoring variable selection : all X
    X_censoring<- as.matrix(X)  
    
    # Hazard pour la censure C with the cumulative hazard inversion method
    epsilon2 <- runif(n, min = 0.00000001, max = 1)
    C <- -log(epsilon2)/(coefC*exp(rowSums(X_censoring %*% diag(parsC))))
    
    # Observed time
    T_obs <- pmin(T_true, C)
    
    # Status
    status <- as.numeric(T_true <= C)
    censor.status <- as.numeric(T_true > C)
    
    # Restricted survival time
    T_obs_tau <- pmin(T_obs,tau)
    status_tau <- as.numeric((T_obs>tau) | (T_obs<=tau &  status == 1 ))}
  
  DATA_target_population <- data.frame(X,tau,A,T0,T1,C,T_obs,T_obs_tau, status,censor.status,status_tau,e)
  
  return(DATA_target_population)
}

```

```{r}
# data simulation with censoring, treatment and time depend to covariates
data_obs2 <- simulate_data_obs(n=2000,tau=50,scenario="Obs2")


#data with no informative censoring
data_obs1 <- simulate_data_obs(n=2000,tau=50,scenario="Obs1")

```

## Data description

```{r,eval=FALSE}
library(survival)
library(ggplot2)
library(survminer)
library(skimr)
#afficher plus visuellement

knitr::kable(skim(data))
#knitr::kable(skim(data_no_cens))

```

The distribution of the death and censoring over the time is displayed
below. The number of patients is displayed on the y-axis and the time on
the x-axis. The censored patients are displayed in purple and the dead
patients are displayed in red.

```{r,eval=FALSE}
ggplot(data, aes(x = T_obs)) +
  geom_histogram(data = subset(data, status == 0), aes(fill = "Censored"), alpha = 0.7, binwidth = 1) +
  geom_histogram(data = subset(data, status == 1), aes(fill = "Dead"), alpha = 0.3, binwidth = 1) +
  labs(x = "Time", y = "Number of patients") +
  scale_fill_manual(name = "Status", values = c("Censored" = "#5f0e91", "Dead" = "#cf6666")) +
  theme(legend.position = "top")

ggplot(data_no_cens, aes(x = T_obs)) +
  geom_histogram(data = subset(data_no_cens, status == 0), aes(fill = "Censored"), alpha = 0.7, binwidth = 1) +
  geom_histogram(data = subset(data_no_cens, status == 1), aes(fill = "Dead"), alpha = 0.3, binwidth = 1) +
  labs(x = "Time", y = "Number of patients") +
  scale_fill_manual(name = "Status", values = c("Censored" = "#5f0e91", "Dead" = "#cf6666")) +
  theme(legend.position = "top")


```

The kaplan meier of the censoring and the survival curve are displayed
below.

The kaplan for censoring is the probability of remaining uncensored.

```{r,eval=FALSE}
kaplan_censoring <- survfit(Surv(time = C, event = censor.status) ~ 1, data = data)

# risk table jusqu'à 80 jours
ggsurvplot(kaplan_censoring, data=data,
  surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
  conf.int = TRUE,             # Affiche les intervalles de confiance
  title = "Censoring Curves (P(C>t)) : Probability of remain uncensored",  # Titre du graphique
  xlab = "Time (days)",        # Étiquette de l'axe x
  ylab = "Censoring Probability" ,# Étiquette de l'axe y
  xlim=c(0,100)
)

```

The survival curve is the probability of remaining alive.

```{r,eval=FALSE}
kaplan <- survfit(Surv(time = T_obs, event = status) ~ 1, data = data)

ggsurvplot(kaplan, data=data,
  surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
  conf.int = TRUE,             # Affiche les intervalles de confiance
  risk.table = TRUE,           # Affiche le tableau des risques en bas du graphique
  risk.table.title = "Risks",  # Titre du tableau des risques
  title = "Survival curve",  # Titre du graphique
  xlab = "Time (days)",        # Étiquette de l'axe x
  ylab = "Survival Probability" # Étiquette de l'axe y
)

```

A stratified analysis by treatment of the survival curve is displayed
below :

```{r,eval=FALSE}
# faire une analyse stratifiée par traitement

kaplan_treatment <- survfit(Surv(T_obs, status) ~ A, data = data)

ggsurvplot(kaplan_treatment, data=data,
  surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
  conf.int = TRUE,             # Affiche les intervalles de confiance
  risk.table = TRUE,           # Affiche le tableau des risques en bas du graphique
  risk.table.title = "Risks",  # Titre du tableau des risques
  title = "Survival curve",  # Titre du graphique
  xlab = "Time (days)",        # Étiquette de l'axe x
  ylab = "Survival Probability" # Étiquette de l'axe y
)

```

As a reminder, $T_{obs_tau}=\min(T_{obs},\tau)$ and
$status_tau=1${(T_obs\>tau \| T_obs \leq tau & status =1)}. Basically,
if the event occurs before $\tau$, the status is 1 and the observed time
doesn't change. If the event or censoring occurs after $\tau$, the
status is 1. The censoring before the threshold time $\tau$ remains the
same.

In estimating kaplan meier in using these parameter, the survival time
is troncated at $\tau$, thus $P(T>\tau)=0$. It allows us to estimate
easily the integral of the survival function up to $\tau$.

In this exemple, $\tau=30$.

```{r,eval=FALSE}
kaplan_treatment_troncated <- survfit(Surv(T_obs_tau, status_tau) ~ A, data = data)

ggsurvplot(kaplan_treatment_troncated, data=data,
  surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
  conf.int = TRUE,             # Affiche les intervalles de confiance
  risk.table = TRUE,           # Affiche le tableau des risques en bas du graphique
  risk.table.title = "Risks",  # Titre du tableau des risques
  title = "Survival curve",  # Titre du graphique
  xlab = "Time (days)",        # Étiquette de l'axe x
  ylab = "Survival Probability" # Étiquette de l'axe y
)

```

It is the exact same curve than but with $P(T>30)=0$ to estimate the
integral of the survival function up to $\tau$ :

```{r,eval=FALSE}
ggsurvplot(kaplan_treatment, data=data,
  surv.median.line = "hv",     # Ajoute les lignes médianes horizontales et verticales
  conf.int = TRUE,             # Affiche les intervalles de confiance
  risk.table = TRUE,           # Affiche le tableau des risques en bas du graphique
  risk.table.title = "Risks",  # Titre du tableau des risques
  title = "Survival curve",  # Titre du graphique
  xlab = "Time (days)",        # Étiquette de l'axe x
  ylab = "Survival Probability", # Étiquette de l'axe y
  xlim=c(0,30)
)
```

## Estimation of RMST

The naive estimator of the average treatment effect is the difference of
the mean of the survival time between the treated and the untreated
group is displayed below :

```{r}

Naive <- function(data){
  T_obs_tau <- data$T_obs_tau
  status_tau <- data$status_tau
  A <- data$A
  mean_naive <- mean(T_obs_tau[A==1]) - mean(T_obs_tau[A==0]) 
  return(mean_naive)
}

Naive(data_rct1)
```

### Kaplan meier estimator

#### Unadjusted Kaplan meier estimator

To ensure that the handmade estimator of Kaplan meier function is
correct, we compare it with the survfit function of the survival
package.

```{r}
data_rct11 <- data_rct1[data_rct1$A==1,]
data_rct10 <- data_rct1[data_rct1$A==0,]

#Plot entre handmade and survfit pour voir si difference sans utiliser ggplot 
km <- Kaplan_meier_handmade(data_rct11,status=data_rct11$status,T_obs=data_rct11$T_obs)
km0 <- Kaplan_meier_handmade(data_rct10,status=data_rct10$status,T_obs=data_rct10$T_obs)
#Mettre sur le même graph le resultat de survfit 
fit <- survfit(Surv(data_rct1$T_obs, data_rct1$status) ~ data_rct1$A)

plot(km$T,km$S, col= "red", lty=1, xlab="Time", ylab="Survival function", main="Handmade KM")
points(km0$T,km0$S, col= "red", lty=1)
lines(fit$time, fit$surv, col= "blue", lty=1)

```

The handmade Kaplan meier estimator (red points) is the same as the survfit function (blue lines)
of the survival package.

##### RMST

The results of the four RMST methods in using the unadjusted Kaplan meier presented in the section @sec-KM are
displayed below :

```{r,eval=FALSE}
#| label : fig-KM-RMST
#| fig.cap : Results of the RMST for the 4 methods
library(dplyr)
library(riskRegression)
library(survminer)
library(survRM2)
# plot des 2 calculs de RMST en fonction de tau : 
# tau doit être infereieur à T_obs max pour les packages SurvRM2
tau <- seq(0,as.integer(max(data_rct1$T_obs)),by=1)
res1_2 <- sapply(tau,function(x) RMST_1_2(data_rct1,tau=x))
res3 <- sapply(tau,function(x) RMST_3(data_rct1,tau=x))
res4 <- sapply(tau,function(x) RMST_4(data_rct1,tau=x))

matplot(tau,res1_2[1,],type="l",lty=1,col=1:2,ylab="RMST",xlab="tau",ylim=c(0,6))+lines(tau,res1_2[2,],lty=2,col=2)+
  lines(tau,res3,lty=3,col=3)+
  lines(tau,res4,lty=3,col=4)+
  abline(h=4,xlim=c(0,50),col="black",lty=2)

```
The 4 methods for compute RMST presented in the section @sec-KM are equivalent


#### Adjusted Kaplan meier estimator

##### RMST  

###### IPCW

```{r}
#| label : fig-KMIPCW-RMST
#| fig.cap : Results of the RMST for the IPCW method

# plot des 2 calculs de RMST en fonction de tau : 
tau <- seq(1,50,by=1)
res5 <- sapply(tau,function(x) IPCW_Kaplan_meier(data_rct1,tau=x))
res6 <- sapply(tau,function(x) IPCW_min(data_rct1,tau=x))

matplot(tau,res5[1,],type="l",lty=1,col=1,ylab="RMST",xlab="tau")+
  #lines(tau,res5[4,],lty=4,col=3)+
  lines(tau,res6[1,],lty=2,col=2)+
  abline(h=4,xlim=c(0,50),col="black",lty=2)

```

###### IPTW

```{r,eval=FALSE}
#| label : fig-KMIPTW-RMST
#| fig.cap : Results of the RMST for the IPTW method

# plot des 2 calculs de RMST en fonction de tau :
tau <- seq(1,50,by=1)
e_hat <- estimate_propensity_score(data_rct1,c("X1","X2","X3","X4"),type_of_model="reglog")
res6 <- sapply(tau,function(x) Adjusted_Kaplan_Meier(data_rct1,e_hat=e_hat,tau=x))


matplot(tau,res6[3,],type="l",lty=1,col=1,ylab="RMST",xlab="tau",ylim=c(0,6))+ 
  abline(h=4,xlim=c(0,50),col="black",lty=2)
  
```

###### IPCW-IPTW 



###### G-formula 

```{r,eval=FALSE}

#Kaplan_meier(data)
e_hat <- estimate_propensity_score(data,c("X1","X2","X3","X4"),type_of_model="reglog")
mean_ipw <- Adjusted_Kaplan_Meier(data,e_hat)
mean_ipw
g_formula_cox_T_learner(data,c("X1","X2","X3","X4"),Y.grid=c(1:30))

```



## Simulation graph

Repeat the simulation 200 times and compare the different estimators in
plotting the distribution of the estimates.

```{r,eval=FALSE}
# Simulation study

#n <- 2000
tau <- 70
n_sim <- 500


all_estimates <- function(data,sample.size,tau){

  results <- data.frame("sample.size" = c(),
                        "estimate" = c(),
                        "estimator" = c(),
                        "nuisance" = c())

  ATE_naive<- Naive(data)
  
  data1 <- data %>%
    dplyr::filter(A==1)
  data0 <- data %>%
    dplyr::filter(A==0)
  km_rct1<- Kaplan_meier_handmade(data1)
  km_rct0 <- Kaplan_meier_handmade(data0)
  ATE_km_rct <- RMST_fromS(S_A1=km_rct1,S_A0=km_rct0,tau=tau)
  
  ATE_pack <- rmst2(data$T_obs, data$status, arm=data$A, tau = tau)[[5]][1]
  
  ATE_km_adj <- IPTW_Kaplan_Meier(data,tau=tau)
  
  ATE_g_formula <- g_formula_cox_T_learner(data,c("X1","X2","X3","X4"),Y.grid=c(1:tau))
  
  ATE_IPCW <- IPCW_Kaplan_meier(data, tau=tau)  
  ATE_IPCW_IPTW <- IPTW_IPCW_Kaplan_Meier(data,tau=tau)

  data.frame <- data.frame("sample.size" = rep(sample.size, 7),
                               "estimate" = c(ATE_naive, ATE_km_rct$RMST,
                                              ATE_km_adj$RMST,ATE_IPCW$RMST, ATE_IPCW_IPTW$RMST, ATE_g_formula,ATE_pack),
                               "estimator" = c("Naive", "KM", "IPTW Adjusted KM", "IPCW Adjusted KM","IPTW-IPCW Adjusted KM", "G_formula cox","Package"),
                               "nuisance" = rep("linear + cox", 7))
  
return(data.frame)
}

compute_estimator<-function(data,n_sim,tau){
data.frame <-  data.frame("sample.size" = c(),
                        "estimate" = c(),
                        "estimator" = c(),
                        "nuisance" = c())
  for (n in c(100,200,500,1000)){
    for (i in 1:n_sim){
      data <- simulate_data_obs(n,tau=tau)
      all <- all_estimates(data,n,tau=tau)
      data.frame <- rbind(all,data.frame)
    }
  }
return (data.frame)
}
```

```{r,eval=FALSE}
# rct1
simulation_rct1<-compute_estimator(data_rct1,n_sim,tau=20)

save(simulation_rct1,file="simulation_rct1.RData")

# rct2
simulation_rct2<-compute_estimator(data_rct2,n_sim)

save(simulation_rct2,file="simulation_rct2.RData")

# obs1
simulation_obs1<-compute_estimator(data_no_cens,n_sim)

save(simulation_obs1,file="simulation_obs1.RData")

# obs2
simulation_obs2<-compute_estimator(data,n_sim)

simulation_obs2 <- simulation2

save(simulation_obs2,file="simulation_obs2.RData")
```

```{r}
load("simulation_rct1.RData")
load("simulation_rct2.RData")
load("simulation_obs1.RData")
load("simulation_obs2.RData")
```

```{r}
library(forecast)
theme_update(plot.title = element_text(hjust = 0.5))

simulation_rct1$sample.size <- as.factor(simulation_rct1$sample.size )

simulation_graph_rct1 <- simulation_rct1 %>%
  ggplot(aes(x = estimator, y = estimate, fill = sample.size)) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("RCT + independent censoring :")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE) +
  xlab("") +
  ylab("ATE") +
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = 4, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "horizontal", legend.text = element_text(size=10)) +
  theme(axis.text = element_text(size=9, face = "bold"),
           axis.title.x = element_text(size=9, face = "bold")) +
  ylim(0,6)
simulation_graph_rct1
```

```{r}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_rct2$sample.size <- as.factor(simulation_rct2$sample.size )

simulation_graph_rct2 <- simulation_rct2 %>%
  ggplot(aes(x = estimator, y = estimate, fill = sample.size)) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("DRCT + dependent censoring")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE) +
  xlab("") +
  ylab("ATE") +
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = 4, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "horizontal", legend.text = element_text(size=10)) +
  theme(axis.text = element_text(size=9, face = "bold"),
           axis.title.x = element_text(size=9, face = "bold")) +
  ylim(0,6)
simulation_graph_rct2
```

```{r}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_obs1$sample.size <- as.factor(simulation_obs1$sample.size )

simulation_graph_obs1 <- simulation_obs1 %>%
  ggplot(aes(x = estimator, y = estimate, fill = sample.size)) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Observational + dependent censoring")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE) +
  xlab("") +
  ylab("ATE") +
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = 4, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "horizontal", legend.text = element_text(size=10)) +
  theme(axis.text = element_text(size=9, face = "bold"),
           axis.title.x = element_text(size=9, face = "bold")) +
  ylim(0,6)
simulation_graph_obs1
```

```{r}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_obs2$sample.size <- as.factor(simulation_obs2$sample.size )

simulation_graph_obs2 <- simulation_obs2 %>%
  ggplot(aes(x = estimator, y = estimate, fill = sample.size)) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Observational + dependent censoring")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE) +
  xlab("") +
  ylab("ATE") +
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = 4, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "horizontal", legend.text = element_text(size=10)) +
  theme(axis.text = element_text(size=9, face = "bold"),
           axis.title.x = element_text(size=9, face = "bold")) +
  ylim(0,6)
simulation_graph_obs2
```

# References {.unnumbered}

::: {#refs}
:::

# Annex {#sec-Annexes}

## Cumulative hazard inversion method {#sec-cumulative-hazard-inversion-method}

When X, a random continuous variable, follow an exponential law (X \~
$\varepsilon(\lambda)$) : the corresponding repartition function is:
$F_{\lambda}(x)=P(X \geq x)=1-\exp(-\lambda x)$ and the density function
is $f_{\lambda}(x)=\lambda \exp(-\lambda x)$.

$F_{\lambda}$ is bijective from $\mathcal{R}^{+}$ to $]0;1[$ thus,
$F_{\lambda}^{-1}$ exists and is also bijective from $]0;1[$ to
$\mathcal{R}^{+}$. The inverse of the repartition function is :
$F^{-1}(u)=\frac{-log(1-u)}{\lambda}$ where U \~ $\mathcal{U}(0,1)$ and
$\frac{-log(1-u)}{\lambda}$ \~ $\varepsilon(\lambda)$.

In knowing that 1-U \~$\mathcal{U}(0,1)$, we can also simulate X as :
$\frac{-log(u)}{\lambda}$ \~ $\varepsilon(\lambda)$.

Following this results, in the case where T, the survival time, follow
an exponential distribution (T \~ $\varepsilon(\lambda)$). The variable
T can be simulated as : $F_\lambda^{-1}(U)=\frac{-log(U)}{\lambda}$
where U \~ $\mathcal{U}(0,1)$.

## Trapezoidal method for integration

The trapezoidal integration method is a numerical technique used to
estimate the integral of a function over a given interval by
approximating the area under the curve with trapezoids. This method is
often employed when the function lacks a simple analytical form or when
the integral cannot be computed exactly.

Suppose we want to estimate the integral of a function \$( f(x) \$) over
the interval $([a, b]$). The trapezoidal method divides this interval
into \$( n \$) subintervals of width \$( h \$), where \$( h =
\frac{b - a}{n} \$).

Each subinterval is approximated by a trapezoid whose bases are the
values of the function \$( f(x) \$) at the endpoints of the subinterval.

The general formula for the area of a trapezoid is:
$$ A = \frac{(b_1 + b_2) \times h}{2} $$ where \$( b_1 \$) and \$( b_2
\$) are the lengths of the parallel bases of the trapezoid, and \$( h
\$) is its height.

To estimate the integral of \$( f(x) \$) over each subinterval, we
calculate the area of each trapezoid and sum them up.

The formula for the trapezoidal integration method for a single pair of
trapezoids is:
$$ \text{Area of trapezoid} = \frac{(f(x_i) + f(x_{i+1})) \times h}{2} $$
where \$( x_i \$) and \$( x\_{i+1} \$) are the lower and upper limits of
subinterval \$( i \$) respectively.

To estimate the integral over the entire interval, we sum the areas of
all the trapezoids: \$\[ \int*{a}\^{b} f(x) , dx\*
\approx \sum{i=1}\^{n} \frac{(f(x_i) + f(x_{i+1})) \times h}{2} \$\]

Below is an example of the trapezoidal integration method used to
estimate the integral of \$( f(x) = x\^2 \$) over the interval
$([0, 1]$) with \$( n = 4 \$) subintervals:

$$ \int_{0}^{1} x^2 \, dx \approx \frac{(f(x_0) + 2f(x_1) + 2f(x_2) + 2f(x_3) + f(x_4)) \times h}{2} $$

Where \$( h = \frac{1 - 0}{4} = \frac{1}{4} \$).

\$\[ \]

Thus,

\$\[ \int\_{0}\^{1} x\^2 , dx
\approx \frac{(0 + 2(1/16) + 2(1/4) + 2(9/16) + 1) \times 1/4}{2} \]

# Session information {.appendix .unnumbered}

```{r session-info}
sessionInfo()
```
