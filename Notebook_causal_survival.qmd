---
title:  "Causal survival analysis"
subtitle:  "Estimation of the Average Treatment Effect (ATE): Practical Recommendations"
author:  
  - name:  Charlotte Voinot
    corresponding:  true
    email:  charlotte.voinot@sanofi.com
    url:  https://chvoinot.github.io/
    affiliations:  
      - name:  Sanofi R&D
        department:  CMEI
        url:  https://www.sanofi.fr/fr/
      - name:  INRIA
        department:  Premedical
        url:  https://www.inria.fr/fr/premedical
      - name:  INSERM
        url:  https://www.inserm.fr/
      - name:  Université de Montpellier
        url:  https://www.umontpellier.fr/
  - name: Clément Berenfeld
    corresponding: true 
    email: clement.berenfeld@uni-potsdam.de
    affiliations: 
      - name: Universität Potsdam, Potsdam, Germany
        departement: Institut für Mathematik
        url: https://www.uni-potsdam.de/en/university-of-potsdam
  - name:  Bernard Sebastien
    corresponding:  true
    email:  bernard.sebastien@sanofi.com
    affiliations:  
      - name:  Sanofi R&D
        department:  CMEI
        url:  https://www.sanofi.fr/fr/
  - name:  Julie Josse
    corresponding:  true
    email:  julie.josse@inria.fr
    url:  https://juliejosse.com/
    affiliations:  
      - name:  INRIA
        department:  Premedical
        url:  https://www.inria.fr/fr/premedical
      - name:  INSERM
        url:  https://www.inserm.fr/
      - name:  Université de Montpellier
        url:  https://www.umontpellier.fr/
 
date:  last-modified
date-modified:  last-modified
keywords:  [Restricted Mean Survival Time, Randomized Control Trial, Observational Study, Censoring]
bibliography:  references.bib
github-user:  chvoinot
repo:  "Simple_simulation_causal_survival"
draft:  false # set to false once the build is running
published:  false # will be set to true once accepted
format:  
  computo-html:  default
  computo-pdf: default
editor:  
  markdown:  
    wrap:  72

header-includes:
  - |
    \newcommand{\bbR}{\mathbb{R}}
    \newcommand{\bbE}{\mathbb{E}}
    \newcommand{\bbP}{\mathbb{P}}
    \newcommand\wt{\widetilde}
    \newcommand\wh{\widehat}
    \newcommand{\ve}{\varepsilon}
    \renewcommand{\epsilon}{\varepsilon}
    \renewcommand\leq{\leqslant}
    \renewcommand\geq{\geqslant}
    \newcommand{\mand}{\quad\text{and}\quad}
    \newcommand{\where}{\quad\text{where}\quad}
    \newcommand{\with}{\quad\text{with}\quad}
    \newcommand{\Var}{\mathrm{Var}}
    \renewcommand{\(}{$}
    \renewcommand{\)}{$}
    \newcommand*\diff{\mathop{}\!\mathrm{d}}
    \newcommand\cF{\mathcal{F}}
    \newcommand\cX{\mathcal{X}}
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{multirow}
    
#    \newtheorem{asu}{Assumption}
#crossref:
#  custom:
#    - kind: float
#      reference-prefix: Assumption
#      key: asu
#      latex-env: asu

#to add to avoid the graph generation
# execute:
#   echo: false
#   eval: false
---

[CB: il faudra penser à décommenter le usepackage orcidlink dans computo/partial/include-in-header pour le build final (c'est ce qui me fait bug la compilation de mon côté)]

[CB: todo pour moi-meme: repercuter les modifs sur $\Delta^\tau$ partout et gerer les cross references pour les hypotheses dans tous les statements / preuve]
[CB: jpense il faut parler des poids stabilisés quelque part ça a l'air important]


# Introduction {#sec-intro}

Causal survival analysis is a growing field that integrates causal inference [@rubin_estimating_1974; @hernan2010causal] with survival analysis to evaluate the impact of treatments on time-to-event outcomes, while accounting for censoring—situations where only partial information about an event's occurrence is available. The most common form of censoring is right-censoring, where the event of interest has not occurred by the last observation, implying it may happen later.

In this field, the causal effect of a treatment is often measured using the Restricted Mean Survival Time (RMST), which offers an intuitive interpretation of the average survival time over a specific period. RMST addresses the limitations of interpreting the hazard ratio as a causal treatment effect [@martinussen_causality_cox; @Martinussen2013; @HR_Martinussen; @Hernan2010_HR], which is often debated due to its potential non-causal nature. Additionally, unlike the hazard ratio, the RMST has the desirable property of being a collapsible measure, meaning that the population effect can be expressed as a weighted average of subgroup effects, with positive weights that sum to 1 [@huitfeldt2019collapsibility; @greenland1999confounding; @pearl2000causality].

However, causal survival analysis is still a relatively new domain, and the existing literature, though vast, remains fragmented. As a result, a clear understanding of the theoretical properties of various estimators is challenging to obtain. Moreover, the implementation of proposed methods is limited, leaving researchers confronted with a range of available estimators and the need to make numerous methodological decisions. There is a pressing need for a comprehensive survey that organizes the available methods, outlines the underlying assumptions, and provides an evaluation of estimator performance-—particularly in finite sample settings.

In this paper, we begin by presenting the necessary notations in @sec-notations. We then detail the identifiability assumptions and available estimators within the context of both randomized trials (@sec-theoryRCT) and observational data (@sec-theoryOBS). We give their statistical properties (consistency, asymptotic normality) and complete the proofs when there were missing. 
Finally, in @sec-simulation, we conduct a numerical comparison of these estimators through simulations under various conditions, including independent and conditionally independent censoring, correct and incorrect model specifications, and violations of positivity assumptions. We conclude with practical recommendations on estimator selection, based on criteria such as convergence behavior, computational complexity, and efficiency.

## Notations and definition of the estimand {#sec-notations} 
[CB: faire une section 1.2 si on fait un section 1.1]

Let's consider ($X_{i},A_{i},C_{i},T_{i}$)  a sample of $n$ i.i.d. realizations of the quadruplet $(X, A, C, T)$  where $X \in \mathbb{R}^p$ denotes the baseline covariates, $A \in \{0, 1\}$ the binary treatment, $C \in \mathbb{R}^+$ the censoring time and $T \in \mathbb{R}^+$ the survival time.

We consider the potential outcome framework by  @rubin_estimating_1974 and note  $T(0)$ the survival time to the event of interest had the patient received control and $T(1)$ the survival time to the event of interest had the patient received treatment. 
In practice, we cannot simultaneously have access to  $T(0)$ and  $T(1)$, as one patient is either treated or control, but only to $T$ defined as follows: 

::: {.assumption}
**Assumption.** (Stable Unit
Treatment Value Assumption: SUTVA)
$$ 
T = AT(1) + (1-A)T(0).
$$ {#eq-sutva}
:::

However, due to censoring, the outcome $T$ is not completely observed  [@censoring_effect] and one only observes  $\tilde T= T \wedge C = \min(T,C)$. When an observation is censored, the observed time is equal to the censoring time. The censoring considered is type II censoring, also known as right censoring.
We further introduce the notation  $\Delta = I\{T \leq C\}$ the status of censoring, where $I\{\cdot\}$ is the indicator function.
The observed and non observed data is represented in @tbl-exemple_data.

\begin{table}
    \centering
    \begin{tabular}{|p{0.4cm}|p{0.4cm}|p{0.4cm}|p{0.4cm}|p{1.7cm}|p{1.7cm}|p{1cm}|p{1cm}|p{1cm}|p{1.5cm}|p{1.5cm}|}
    \hline
        ID & \multicolumn{3}{c|}{Covariates} & Treatment & Censoring & Status & \multicolumn{2}{c|}{Potential outcome} & Partially observed outcome & Observed outcome \\ \hline
        ~ & $X_{1}$ & $X_{2}$ & $X_{3}$ & A & C & $\Delta$ & T(0) & T(1) & T & $\tilde{T}$ \\ \hline
        1 & 1 & 1.5 & 4 & 1 & ? & 1 & ? & 200 & 200 & 200 \\ \hline
        2 & 5 & 1 & 2 & 0 & ? & 1 & 100 & ? & 100 & 100 \\ \hline
        3 & 9 & 0.5 & 3 & 1 & 200 & 0 & ? & ? & ? & 200 \\ \hline
    \end{tabular}
    \caption{Example of survival data with covariates, treatment, the censoring
time, the status of censoring and the potential outcomes, the partially observed outcome and the observed outcomes.}
    \label{tbl-exemple_data}
\end{table}

Our aim is to estimate the Average Treatment Effect (ATE) defined as the difference between the restricted mean survival time of the treated and controls  [@RMST].

::: {#def-ATE}
### Causal effect: Difference between Restricted Mean Survival Time[^1]

$$
\theta_{\mathrm{RMST}} = \mathbb{E}\left[T(1) \wedge \tau - T(0) \wedge \tau\right], 
$$
with $T \wedge \tau = \min(T,\tau)$, the truncated partial outcome
at $\tau$,  with $\tau$ a fixed time horizon. 

[^1]: The causal effect can be also measured as the difference of the survival probability between treated and control [@Ozenne20_AIPTW_AIPCW].

:::

Let us note $S^{(a)}(t):=\mathbb{P}(T(a) > t)$ for $a \in \{0,1\}$ the survival curves, i.e., the probability that a
treated or non-treated individual will survive beyond a given time $t$. Likewise, we let $S(t) := \bbP(T >t)$, and $S_C(t) := \bbP(C > t)$. We also let $G(t) := \bbP(C \geq t)$ be the left-limit of the survival function $S_C$.
Because $T(a) \wedge \tau$ are non-negative random variables, one can express the restricted mean survival time using the survival functions:

$$
\mathbb{E}(T(a) \wedge \tau) = \int_{0}^{\infty} \mathbb{P}(T(a)\wedge \tau > t)dt = \int_{0}^{\tau}S^{(a)}(t)dt.
$$ {#eq-rmstsurv}
Consequently, $\theta_{\mathrm{RMST}}$ can be interpreted as the mean
difference between the survival function of treated and control until a
fixed time horizon $\tau$.  A
difference in RMST $\theta_{\mathrm{RMST}} = 10$ days with $\tau=200$
means that on average the treatment increases the survival time by 10
days at 200 days.
The difference in RMST, illustrated in @fig-RMST, is a time-dependent
measure that varies with the value of $\tau$.

![Plot of Kaplan-Meier survival curve for treated and control. The
 $\theta_{\mathrm{RMST}}$ at $\tau=50$ corresponds to the yellow shaded area between the two survival curves.](KM_RMST.pdf){#fig-RMST}

# Causal survival analysis with a Randomized Control Trial {#sec-theoryRCT}

Randomized clinical trials (RCTs) are the gold standard for establishing
the effect of a treatment on an outcome, because treatment allocation is controlled through randomization, which ensures (asymptotically) the balance of covariates
between treated and controls, and thus avoids problems of confounding
between treatment groups. The core assumption in a classical RCT is the
random assignment of the treatment [@rubin_estimating_1974].

::: {.assumption}
**Assumption.**
(Random treatment assignment) There holds:
$$ 
A \perp\mkern-9.5mu\perp(T(0),T(1),X)
$$ {#eq-rta}
:::

We also assume that there is a positive probability of receiving the treatment, which we rephrase under the following assumption. 

::: {.assumption}
**Assumption.** (Trial positivity)
$$ 
0 < \mathbb{P}(A=1) < 1
$$ {#eq-postrial}
::: 


Under @eq-rta and @eq-postrial, classical causal identifiability equations can be written to express  $\theta_{\mathrm{RMST}}$ without potential outcomes. 

$$
\begin{aligned}
    \theta_{\mathrm{RMST}} &=  \mathbb{E}[T(1) \wedge \tau - T(0) \wedge \tau]\\
    &= \mathbb{E}[T(1) \wedge \tau | A = 1] - \mathbb{E}[ T(0) \wedge \tau| A= 0]  && \tiny\text{(Random treatment assignment)} \\
       &= \mathbb{E}[T \wedge \tau | A = 1] - \mathbb{E}[ T \wedge \tau| A= 0].  && \tiny\text{(SUTVA)}
\end{aligned}
$$ {#eq-RMSTkm}

However, @eq-RMSTkm still depends on $T$, which remains only partially observed due to censoring. To ensure that censoring does not compromise the identifiability of treatment effects, we must impose certain assumptions on the censoring process,
standards in survival analysis, namely, independent censoring and conditionally independent censoring. These assumptions lead to different estimation approaches. We focus on two strategies: those that aim to directly estimate  $\mathbb{E}[T \wedge \tau | A = a]$ directly (e.g., through censoring-unbiased transformations, see @sec-condcens), and those that first estimate the survival curves to derive RMST via @eq-rmstsurv (such as the Kaplan-Meier estimator and all its variants, see [CB: todo]).

## Independent censoring {#sec-theoryRCT_indc}

The most well-known assumption about censoring in survival analysis is that of independent censoring:

::: {.assumption}
**Assumption.** (Independent censoring)
$$ 
C \perp\mkern-9.5mu\perp(T(0),T(1),X,A)
$$ {#eq-independantcensoring}
:::

Under @eq-independantcensoring, subjects censored at time $t$ are representative of all subjects who remain at risk at time $t$. It is as if the censored subjects were randomly selected from all subjects. @fig-RCT_ind_causalgraph represents the causal graph when the
study is randomized and outcomes are observed under independent censoring.

![Causal graph in RCT survival data with
independent censoring.](causal_survival_rct_indep.pdf){#fig-RCT_ind_causalgraph fig-align="center" width="40%"}

We also assume that there is no almost-sure upper bound on the censoring time before $\tau$, which we rephrase under the following assumption. 

::: {.assumption}
**Assumption.** (Positivity of the censoring process) There exists $\ve > 0$ such that
$$ 
G(t) \geq \ve \quad \text{for all} \quad t \in [0,\tau).
$$ {#eq-poscen}
::: 

If indeed it was the case that $\bbP(C < t) = 1$ for some $t < \tau$, then we would not be able to infer anything on the survival function on the interval $[t,\tau]$ as all observation times $\wt T_i$ would be in $[0,t]$ almost surely.
The two Assumptions [-@eq-independantcensoring] and [-@eq-poscen] together allow the distributions of $T(a)$ to be identifiable, in the sense that there exists an identity that expresses $S^{(a)}$ as a function of the joint distribution of $(\wt T,\Delta,A=a)$, see for instance @ebrahimi2003identifiability for such a formula in a non-causal framework. This enables several estimation strategies, the most well-known of which being the Kaplan-Meier product limit estimator.

### Estimation with Kaplan-Meier {#sec-unadjustedKM}

To motivate the definition of the latter and explicit the identifiability identity, let us set the analysis in the discrete case. We let $\{t_k\}_{k \geq 1}$ be a set of positive and increasing times and assume that $T \in \{t_k\}_{k \geq 1}$ almost surely. Then for any $t \in [0,\tau]$, it holds, letting $t_0 = 0$ by convention.

\begin{align*}
S(t| A=a) &= \bbP(T > t|A=a) = \prod_{t_k \leq t} \bbP(T > t_k | T > t_{k-1}, A=a) \\
&= \prod_{t_k \leq t} \left(1 - \bbP(T \leq t_k | T > t_{k-1}, A=a)\right) \\
&= \prod_{t_k \leq t} \left(1 - \frac{\bbP(T = t_{k}, A=a)}{\bbP(T \geq t_{k},A=a)}\right).
\end{align*}

Using Assumptions [-@eq-independantcensoring] and [-@eq-poscen], we find that 
$$
\frac{\bbP(T = t_{k}, A=a)}{\bbP(T \geq t_{k},A=a)} = \frac{\bbP(T = t_{k},C \geq t_k,A=a)}{\bbP(T \geq t_{k}, C\geq t_k,A=a)} =  \frac{\bbP(\wt T = t_{k}, \Delta = 1,A=a)}{\bbP( \wt T \geq t_{k},A=a)},
$$
yielding the final identity
$$ 
S(t|A=a) = \prod_{t_k \leq t} \left(1-\frac{\bbP(\wt T = t_{k}, \Delta = 1,A=a)}{\bbP( \wt T \geq t_{k},A=a)}\right).
$${#eq-kmi}
This last equation suggests in turn to introduce the quantities
$$
D_k(a) := \sum_{i=1}^n I(\wt T_i = t_k, \Delta_i = 1, A=a) \mand N_k(a) := \sum_{i=1}^n I(\wt T_i \geq t_k, A=a),
$$ {#eq-dknk}
which correspond respectively to the number of deaths $(D_k)$ and of individuals at risk $(N_k)$ at time $t_k$ in the treated group (a=1) or in the control group (a=0). 

::: {#def-km}
(Kaplan-Meier estimator, @kaplan)
With $D_k(a)$ and  $N_k(a)$ defined in @eq-dknk, we let

$$
    \wh{S}_{\mathrm{KM}}(t|A=a) := \prod_{t_k \leq t}\left(1-\frac{D_k(a)}{N_k(a)}\right).
$$ {#eq-unadjKM}
:::
The assiociated RMST estimator is then simply defined as
$$
\wh{\theta}_{\mathrm{KM}} = \int_{0}^{\tau}\wh{S}_{KM}(t|A=1)-\wh{S}_{KM}(t|A=0)dt.
$$ {#eq-unadjKM}
The Kaplan-Meier estimator is the Maximum Likelihood Estimator (MLE) of the survival functions, see for instance @kaplan. Furthermore, because $D_k(a)$ and $N_k(a)$ are sums of i.i.d. random variables, the Kaplan-Meier estimator inherits some convenient statistical properties. 

::: {#prp-km}
Under Assumptions [-@eq-sutva; -@eq-rta; -@eq-postrial; -@eq-independantcensoring] and [-@eq-poscen], and for all $t \in [0,\tau]$, the estimator $\wh S_{\mathrm{KM}}(t|A=a)$  of  $S^{(a)}(t)$ is strongly consistent and admits the following bounds for its bias:
$$
0 \leq S^{(a)}(t) - \bbE[\wh S_\mathrm{KM}(t|A=a)] \leq O(\bbP(N_k(a) = 0)),
$$
where $k$ is the greatest time $t_k$ such that $t \geq t_k$.
:::

@gill1983large gives a more precise lower-bound on the bias in the case of continuous distributions, which was subsequently refined by @zhou1988two. The bound we give, although slightly looser, still exhibits the same asymptotic regime. In particular, as soon as $S^{(a)}(t) > 0$ (and Assumption [-@eq-poscen] holds), then the bias decays exponentially fast towards $0$. We give in @sec-proof21 a simple proof of our bound is our context.

::: {#prp-varkm}
Under Assumptions [-@eq-sutva; -@eq-rta; -@eq-postrial; -@eq-independantcensoring] and [-@eq-poscen], and for all $t \in [0,\tau]$, $\wh S_{\mathrm{KM}}(t|A=a)$ is asymptotically normal and $\sqrt{n}\left(\wh S_{\mathrm{KM}}(t|A=a) - S^{(a)}(t)\right)$ converges in distribution towards a centered Gaussian of variance
$$
V_{\mathrm{KM}}(t|A=a) := S^{(a)}(t)^2 \sum_{t_k \leq t} \frac{1-s_k(a)}{s_k(a) r_k(a)},
$$
where $s_k(a) = S^{(a)}(t_k)/S^{(a)}(t_{k-1})$ and $r_k(a) = \bbP(\wt T \geq t_k, A=a)$.
:::
The proof of @prp-varkm can be found in @sec-proof21. Because $D_k(a)/N_k(a)$ is a natural estimator of $1-s_k(a)$ and, $\frac{1}{n} N_k(a)$ a natural estimator for $r_k(a)$, the asymptotic variance of the Kaplan-Meier estimator can be estimated with the so-called Greenwood formula, as already derived heuristically in @kaplan:
$$
\wh \Var \left(\wh{S}_{\mathrm{KM}}(t|A=a)\right) := \wh{S}_{\mathrm{KM}}(t|A=a)^2 \sum_{t_k \leq t} \frac{D_k(a)}{N_k(a)(N_k(a)-D_k(a))}.
$$ {#eq-varkm}
We finally mention that the KM estimator as defined in @def-km still makes sense in a non-discrete setting, and one only needs to replace the fixed grid  $\{t_k\}$ by the values at which we observed an event $(\wt T_i = t_k, \Delta_i =1)$. We refer to @Kaplan_consistency_breslow74 for a study of this estimator in the continuous case and to @Aalen2008, Sec 3.2 for a general study of the KM estimator through the prism of point processes.


### Estimation with Cox model {#sec-cox}

Building on @eq-RMSTkm, we can also express the RMST as a function of the conditionnal response:

\begin{align*}
 \theta_{\mathrm{RMST}} = \mathbb{E}\left[\mathbb{E}[T \wedge \tau |X, A = 1]\right] - \mathbb{E}\left[ T \wedge \tau|X, A= 0]\right]. 
\end{align*}

If we were provided with an estimator $\wh \mu(x,a)$ of 
$$
\mu(x,a) := \mathbb{E}[T \wedge \tau |X = x, A = a],$$
we could consider the following plug-in estimator of the RMST, also known as the G-formula:

$$ \widehat{\theta}_{\mathrm{G-formula}} = \frac{1}{n} \sum_{i=1}^n \wh \mu\left(X_i, 1\right)-\wh \mu\left(X_i, 0\right). $${#eq-gformula}

The Cox proportional hazards model [@Cox_1972] is one of the most widely used estimators for conditional response in survival analysis. This model assumes that the hazard function [CB: need to properly define the hazard function somewhere before] at time $t$ is associated with  baseline covariates $X$ as follows:

$$
\lambda(t|A=0,X)= \lambda_0(t)e^{\beta_0^T X},
$$
where $\lambda_0(.)$ is an unspecified baseline hazard function, and $\beta_0$ is a $p \times 1$ vector of 
unknown regression parameters. Then, the conditional survival curve can be expressed as:

$$
S(t \mid Z)=\mathrm{e}^{-\Lambda_0(t) \exp \left(\beta_0^{T} X\right)}
$$

The estimator of the cumulative hazard function $\hat\Lambda_0(t)$ and $\hat\beta_0$ can be obtained by using the Maximum of Likelihood Estimator and the Breslow estimator (approximation of the Maximum of Likelihood in proportional hazards regression) [@Breslow_approx1974].

@fig-gf illustrates the estimation of the difference in Restricted Mean Survival Time using G-formula. 

![Illustration of the G-formula for estimating
$\theta_{\mathrm{RMST}}$ in an RCT when only one covariates $X_1$ influences the  outcome](G_formula_RCT.pdf){#fig-gf width="110%"}

<!--In @Shen1997, it is shown that the asymptotic unbiasedness of the mean survival estimate [CV: C'est pas vraiment notre estimateur qui est présenté dans l'article.. Ils considèrent un estimateur qui donne la courbe de survie moyenne. J'hesite à le garder. Sinon @Karrison_2018 peut être plus adapté mais peu/pas de math], and its higher efficiency 
relative to the Kaplan-Meier estimate in the mean squared error sense. -->

It is possible to use other methods to estimate the conditional survival function such as parametric survival models (for example a Weibull model) or non-parametric models such as survival forests [@ishwaran2008random].

In causal inference, the goal is to estimate the parameter of interest here $\theta_{RMST}$. To achieve this, it is necessary to estimate intermediate quantities, such as the conditional survival function in this case. These intermediate quantities are  referred to as nuisance parameters. [CB: c'est à developper?]

[CB: ce serait bien de state des results dans cette sous-section]

## Conditionally independent censoring {#sec-condcens}

An alternative hypothesis in survival analysis that relaxes the assumption of independent censoring is conditionally independent censoring.

::: {.assumption}
**Assumption.** (Conditionally independent censoring)
$$ 
C \perp\mkern-9.5mu\perp(T(0),T(1))|X,A
$$ {#eq-condindepcensoring}
:::

Under @eq-condindepcensoring, subjects within a same stratum defined by $X=x$ and $A=a$ have equal probability of censoring at time $t$, for all $t$. 

In case of conditionally independent censoring,  we also need to assume that all subjects have a positive probability to remain uncensored at their time-to-event.

::: {.assumption}
**Assumption.** (Positivity / Overlap for censoring)
There exists $\ve > 0$ such that for all $t\in [0,\tau)$, it almost surely holds
$$ 
G(t|A,X) \geq \epsilon.
$$ {#eq-positivitycensoring}
:::

This assumption ensures that, for any time $t \leq \tau$, the probability of censoring within subgroups is not equal to 1, allowing for balance in the censoring mechanism [IM: do you mean non-empty risk sets at any time t? I'm not sure what is meant by balanced censoring mechanism]. If violated, it means that results are either only observed after time $t$, which can limit the analysis [IM: from the formulation at the beginning of the sentence it sounds like there is another possible consequence of the violation]. 

In practice, adjusting the threshold time $\tau$ can help meet this assumption. For example, in a 5-year clinical study, if patients leave due to severe side effects or worsening health, censoring becomes dependent. In such cases, the likelihood of remaining uncensored for severely ill patients at 5 years is zero. To address this, $\tau$ can be adjusted so that participants have a chance to remain uncensored up to a revised threshold time.                                                                              
@fig-RCT_dep_causalgraph represents the causal graph when the
study is randomized with conditionally independent censoring.

![Causal graph in RCT survival data with
dependent censoring.](causal_survival_rct_dep.pdf){#fig-RCT_dep_causalgraph fig-align="center" width="40%"}

Under Assumptions [-@eq-condindepcensoring] and [-@eq-positivitycensoring], the
Kaplan-Meier estimator as defined in @def-km can fail to estimate survival
probabilities due to conditionally independent censoring [@IPCW]. One classical strategy to circumvent this effect is to use so-called _censoring unbiased transformation_.

**Censoring unbiased transformation** 
Censoring unbiased transformations involve applying a transformation to $T$. Specifically, we compute a new time $T^*$ of the form
$$
T^* = \begin{cases}
\phi_0(\wt T \wedge \tau,X,A) \quad &\text{if} \quad \Delta^\tau = 0, \\
\phi_1(\wt T \wedge \tau,X,A) \quad &\text{if} \quad \Delta^\tau = 1.
\end{cases}
$$ {#eq-defcut}
for two wisely chosen transformations $\phi_0$ and $\phi_1$, and where 
$$\Delta^{\tau}:=I\{T \wedge \tau \leq C\} = \Delta+(1-\Delta)I(\wt T \geq \tau)
$$ {#eq-defdeltatau}
is the indicator of the event where the individual is either uncensored or censored after time $\tau$. The idea behind the introduction of $\Delta^\tau$ is that because we are only interested in computed the expectation of the survival time thresholded by $\tau$, any censored observation coming after time $\tau$ can in fact be considered as uncensored ($\Delta^\tau = 1$). 

A censoring unbiased transformation $T^*$ shall satisfy:
$$
\bbE[T^*|A,X] = \bbE[T \wedge \tau |A,X] \quad\text{almost surely.}
$${#eq-cut}
A notable advantage of this
approach is that it enables the use of the full transformed dataset $(X_i,A_i,T^*_i)$ as if no censoring occured.
  

The two most popular transformations are Inverse-Probability-of-Censoring Weighting (@IPCtransKoul81) and Buckley-James (@Buckley_james_79), both illustrated in @fig-trans and detailed below. In the former, only non-censored observations are considered and they are weighted while in the latter, censored observations are imputed with an estimated survival time.

![Illustration on Inverse-Probability-of-Censoring and Buckley-James
transformation](schema_transformation.pdf){#fig-trans}

### The Inverse-Probability-of-Censoring Weighted transformation {#sec-ipcw}

The Inverse-Probability-of-Censoring Weighted (IPCW) transformation  involves discarding censored observations and applying weights to uncensored data. More precisely, we define
$$
T^*_{\mathrm{IPCW}}=\frac{\Delta^\tau}{G(\widetilde{T}\wedge \tau|X,A)} \widetilde{T} \wedge \tau ,
$$ {#eq-defipcw}
where we recall that $G(t|X,A) :=\mathbb{P}(C \geq t|X,A)$ is the left limit of the conditional survival function of the censoring. 
This estimator assigns higher weights to uncensored subjects within the
same covariate group, correcting for conditionally independent censoring and reducing selection bias [@Howe2016SelectionBD].

::: {#prp-ipcw}
Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], the IPCW transform [-@eq-defipcw] is a censoring unbiased transformation in the sense of @eq-cut.
:::

The proof of @prp-ipcw is in @sec-proof22. The IPCW depends on the unknown conditional survival function of the censoring $G(\cdot|X,A)$, which thus needs to be estimated. We refer to Section @sec-cox for a development regarding the estimation of this quantity. Estimating conditional censoring or the conditional survival function can be approached similarly, as both involve estimating a time—whether for survival or censoring. Consequently, we can use semi-parametric methods, such as the Cox model, or non-parametric approaches like survival forests. Once an estimator $\wh G(\cdot|A,X)$ of the later is provided, a very natural estimator of the RMST based on the IPCW transformation would be
$$
\wh \theta_{\mathrm{IPCW}} = \sum_{i=1}^n \left(\frac{A_i}{n_{1}}-\frac{1-A_i}{n_{0}}\right)\frac{\Delta_i^\tau}{\wh G(\wt T \wedge \tau | A_i,X_i)} \wt T_i, \ 
$$
where $n_a := \#\{i \in [n]~|~A_i=a\}$. 

::: {#prp-ipcwcons}
Under Assumptions[-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], if $\wh G$ is uniformly weakly (resp. strongly) consistent then so is $\wh \theta_{\mathrm{IPCW}}$.
:::

The proof of @prp-ipcw can be found in @sec-proof22. Surprisingly, we found limited use of this estimator in the literature, beside its first introduction in @IPCtransKoul81. This could potentially be explained by the fact that, empirically, we observed that this estimator is highly variable. Consequently, we do not explore its properties further and will not include it in the numerical experiments. A related estimator is the IPCW-Kaplan-Meier defined as follows. 

::: {#def-ipcwkm} 
(IPCW-Kaplan-Meier)
We let again $\wh G(\cdot|X,A)$ be an estimator of the (left limit of) the conditional censoring survival function and we introduce

\begin{align*}
D_k^{\mathrm{IPCW}}(a) &:= \sum_{i=1}^n \frac{\Delta_i^\tau}{\wh G(\wt T_i \wedge\tau | X_i,A=a)} I(\wt T_i = t_k, A_i=a) \\
\mand N^{\mathrm{IPCW}}_k(a) &:= \sum_{i=1}^n \frac{\Delta_i^\tau}{\wh G(\wt T_i \wedge\tau | X_i,A=a)} I(\wt T_i \geq t_k, A_i=a),
\end{align*}

be the weight-corrected numbers of deaths and of individual at risk at time $t_k$. The IPCW version of the KM estimator is then defined as: 
$$
\begin{aligned}
\wh{S}_{\mathrm{IPCW}}(t | A=a) &= \prod_{t_k \leq t}\left(1-\frac{D_k^{\mathrm{IPCW}}(a)}{N_k^{\mathrm{IPCW}}(a)}\right). 
\end{aligned}
$$
:::


The subsequent RMST estimator then take the simple form
$$
\wh{\theta}_{\mathrm{IPCW-KM}} = \int_{0}^{\tau}\wh{S}_{\mathrm{IPCW}}(t|A=1)-\wh{S}_{\mathrm{IPCW}}(t|A=0)dt.
$$ {#eq-thetaIPCWKM}
Like before for the classical KM estimator, this new reweighted KM estimator enjoys good statistical properties.

::: {#prp-ipcwkm}
Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], and for all $t \in [0,\tau]$, the oracle estimator $S^*_{\mathrm{IPCW}}(t|A=a)$ defined as in @def-ipcwkm with $\wh G = G$ is a stronlgy consistent and asymptotically normal estimator of $S^{(a)}(t)$ .
:::


The proof of @prp-ipcwkm can be found in @sec-proof22. Because the evaluation of $N_k^{\textrm{IPCW}}(a)$ now depends on information gathered after time $t_k$ (through the computation of the weights), the previous proofs on the absence of bias and on the derivation of the asymptotic variance unfortunately do not carry over in this case. Whether its bias is exponentially small and whether the asymptotic variance can be derived in a closed form are questions left open. We are also not aware of any estimation schemes for the asymptotic variance in this context. In the case where we do not have access to the oracle survival function $G$, we can still achieve consistency and asymptotic normality if the estimator $\wh G(\cdot|A,X)$ that we provide is consistent, as shown in @sec-proof22 and stated below.

::: {#prp-ipcwkmcons}
Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], if $\wh G$ is uniformly weakly (resp. strongly) consistent then so is $\wh S_{\mathrm{IPCW}}(t|A=a)$.
:::




<!--[CB: est-ce qu'on peut avoir un exemple de papier qui cite cette publi introuvable?] [CV:  https://doi.org/10.1111/j.0006-341X.2001.00343.x (section 6)]

@robins1993 **(fameuse publi introuvable mais très cité)** [LB: https://scholar.google.com/scholar_lookup?journal=Proceedings+of+the+Biopharmaceutical+Section,+American+Statistical+Association&title=Information+recovery+and+bias+adjustment+in+proportional+hazards+regression+analysis+of+randomized+trials+using+surrogate+markers&author=JM+Robins&publication_year=1993&pages=24-33& c'est pas ça ?] shows that our IPCW estimate $\hat{S}_{IPCW-KM}(t,a)$ is guaranteed to be
consistent and asymptotically normal under @eq-condindepcensoring and
when the model of conditional censoring is correct [@Robins2004]. Also,
@IPCWrobins shows that the IPCW estimate is asymptotically more efficient
than the standard Kaplan-Meier estimator for failure in treatment arm $a$
whenever the latter estimator is consistent (i.e., whenever censoring is
independent). [CB: je ne comprends pas ce que ça veut dire] [IM: +1]
[CV: A refaire]-->


### The Buckley-James transformation {#sec-BJ}

One weakness of the IPCW transformation is that it discards all censored data. The Buckley-James (BJ) transformation takes a different path by leaving all uncensored values untouched, while replacing the censored ones by an extrapolated value. Formally, it is defined as follows:

$$
\begin{aligned}
T^*_{\mathrm{BJ}} &= \Delta^\tau (\widetilde{T}\wedge\tau) + (1-\Delta^\tau) Q_S(\widetilde T \wedge \tau|X,A),
\end{aligned}
$$ {#eq-defbj}

where, for $t \leq \tau$,
$$Q_S(t|X,A) :=\mathbb{E}[T \wedge \tau | X,A,T \wedge \tau > t]= \frac{1}{S(t|X,A)}\int_{t}^{\tau} S(u|X,A) \diff u$$ where $S(t|X,A=a) := \bbP(T(a) > t|X)$ is the conditional survival function.


::: {#prp-bj}
Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], the BJ transform [-@eq-defbj] is a censoring unbiased transformation in the sense of @eq-cut.
:::

The proof of @prp-bj can be found in @sec-proof22. Again, the BJ transformation depends on a nuisance parameter (here $Q_S(\cdot|X,A)$) that needs to be estimated. We refer to Sec [CB: todo] for a brief overview of possible estimation strategies for $Q_S$. 
Once provided with an estimator $\wh Q_S(\cdot|A,X)$, a very natural estimator of the RMST based on the BJ transformation is
$$
\wh \theta_{\mathrm{BJ}} = \sum_{i=1}^n \left(\frac{A_i}{n_1}-\frac{1-A_i}{n_0}\right)\left\{\Delta_i^\tau (\wt T_i \wedge\tau) + (1-\Delta_i^\tau) \wh Q_S(\wt T_i \wedge \tau|X_i,A_i))\right\}. 
$${#eq-BJ}
Like for the IPCW tranformation, the BJ transformation yields a consistent estimate of the R:ST as soon as the model is well-specified.

::: {#prp-bjcons}
Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring],  if $\wh Q_S$ is uniformly weakly (resp. strongly) consistent then so is $\wh \theta_{\mathrm{BJ}}$.
:::

<!-- The proof of this result can be found in @sec-proof22. If the nuisance parameters are not well estimated, the estimator using -->
<!-- the transformation will be biased [@Fan1994LocalPM; @DoublyR_transformation] [CB: il y a vraiment un resultat sur le biais en cas de mispecification dans ces refs?]. -->
<!-- <!--A non-parametric transformation has been developed by @LocalLinear_Fan94. --> -->

The proof of this result can be found in @sec-proof22. The BJ transformation is considered as the best censoring transformation of the original response in the following sense.

::: {#thm-bj}
For any transformation $T^*$ of the form [-@eq-defcut], it holds
$$
\bbE[(T^*_{\mathrm{BJ}}-T \wedge \tau)^2] \leq \bbE[(T^*-T \wedge \tau)^2].
$$
:::

This result is stated in @LocalLinear_Fan94 but without a proof. We detail it in @sec-proof22 for completeness.

### Augmented corrections {#sec-tdr}

The main disadvantage of the two previous transformations is that they heavily rely on the specification of good estimator $\wh G$ (for IPCW) or $\wh S$ (for BJ). In order to circumvent this limitation, @DoublyR_transformation proposed the following transformations, whose expression is based on theory of semi-parametric estimation developed in @vanderLaan2003,    
$$
T^*_\mathrm{DR} = \frac{\Delta^\tau \wt T\wedge \tau}{G(\wt T \wedge \tau|X,A)} + \frac{(1-\Delta^\tau)Q_S(\wt T \wedge \tau |X,A)}{G(\wt T \wedge \tau |X,A)}- \int_0^{\wt T \wedge \tau} \frac{Q_S(t|X,A)}{G(t|X,A)^2} \diff G(t|X,A).
$$ {#eq-TDR}
This transformations depends on the knowledge of both conditional survival functions $G$ and $S$ and will be thus sometimes denoted $T^*_\mathrm{DR}(G,S)$ to stress this dependency. This transformations is not only a censoring unbiased transform in the cens of @eq-cut, but is also doubly robust in the following sense.

:::{#prp-tdr}
We let $J,H$ be two conditional survival functions. Under Assumptions [-@eq-sutva;-@eq-rta,-@eq-postrial;-@eq-condindepcensoring] and [-@eq-positivitycensoring], if $F$ also satisfies Assumption [-@eq-positivitycensoring], and if $F(\cdot|X,A)$ is absolutely continuous wrt $G(\cdot|X,A)$, then the transformation $T^*_\mathrm{DR} = T^*_\mathrm{DR}(F,R)$ satisfy 
$$
\bbE[T^*_\mathrm{DR} |X,A] = \bbE[T \wedge \tau |X,A]\quad\text{if}\quad F = G \quad \text{or}\quad R=S.
$$
:::
The statement and proof of this results is found in @DoublyR_transformation in the case where $C$ and $T$ are continuous. A careful examination of the proofs show that the proof translates straight away to our discrete setting.


# Causal survival analysis with an observational study {#sec-theoryOBS}

The previous estimators are suited for randomized controlled trial (RCT) settings but not for more complex contexts like observational studies. Unlike RCT, observational data --- such as from registries, electronic health records, or national healthcare systems --- are collected without controlled randomized treatment allocation.
In such cases, treated and control groups are likely unbalanced due to the non-randomized design. As a result, the treatment effect is confounded by variables
 which influence both the time-to-event outcome $T$ and the treatment allocation $A$.
The assumption of randomized treatment assignment, as presented in
@eq-rta (see @sec-theoryRCT), is not satisfied in
observational studies. To enable the identifiability of the causal
estimand, additional assumptions regarding treatment allocation are
needed. These assumptions are standard in causal inference methods with
observational data and can be extended to identify $\theta_{\mathrm{RMST}}$:

::: {.assumption}
**Assumption.** (Conditional exchangeability / Unconfoundedness) It holds
$$ 
 A \perp\mkern-9.5mu\perp(T(0),T(1)) | X
$$ {#eq-unconf} 

:::

Under @eq-unconf, the treatment assignment is randomly
assigned conditionally on the covariates $X$. It is as if the treatment
for all subjects were randomly selected inside each subgroup. Exactly
like @eq-condindepcensoring, this assumption assumes that there are no
unmeasured confounders as unobserved confounders make it impossible to
distinguish correlation from causality.

::: assumption
**Assumption.** (Positivity / Overlap for treatment) For $a\in\{0,1\}$, it holds

$$ 
0 < P(A=a \mid X) <1 \quad \text{almost surely.}
$$ {#eq-positivitytreat}
:::

The @eq-positivitytreat assumption requires adequate overlap in
covariate distributions between treatment groups, meaning every
observation must have a non-zero probability of being treated.

In addition to confounding bias, censoring bias must also be addressed,
as discussed in @sec-theoryRCT. The censoring mechanism assumptions from
@eq-condindepcensoring  and @eq-independantcensoring remain  applicable. The next section will present
the identifiability formula and corresponding estimator
when censoring is independent in observational studies. 

Because Assumption [-@eq-sutva] does not hold anymore, neither does the previous idenfiability @eq-RMSTkm. Letting the propensity score $e(X) := \bbP(A=1|X)$ (which is in $(0,1)$ almost surely, thanks to Assumption [-@eq-positivitytreat]), we can write

$$
\begin{aligned}
    \theta_{\mathrm{RMST}} &=  \mathbb{E}[T(1) \wedge \tau - T(0) \wedge \tau]\\
    &= \mathbb{E}\left[\bbE[T(1) \wedge \tau|X] - \bbE[T(0) \wedge \tau|X] \right]  &&  \\
    &=\mathbb{E}\left[\bbE[T(1) \wedge \tau|X, A=1] - \bbE[T(0) \wedge \tau|X, A=0]\right]   && \tiny\text{(unconfoundness)} \\
       &= \mathbb{E}\left[\bbE[T \wedge \tau|X, A=1] - \bbE[T \wedge \tau|X, A=0]\right].  && \tiny\text{(SUTVA)}
\end{aligned}
$$ {#eq-identcond}
In another direction, one could wish to identify the treatment effect through the survival curve as in @eq-rmstsurv:
$$
S^{(a)}(t) = \bbP(T(a) > t) = \bbE\left[\bbP(T > t | X, A=a)\right].
$$ {#eq-kmcond}
Again, both identities still depend on the unknown quantity $T$ and suggest two different estimation strategies. These strategies differ according to the censoring assumptions and are detailed below. 

## Independent censoring {#sec-obs_indcen}

@fig-causalgraph_obs_ind illustrates a causal graph in observational survival data with independent censoring (Assumption [-@eq-independantcensoring]).

![Causal graph in observational survival data
with independent censoring (A is the treatment, $X$ the confounding
variable and $T$ is the survival time outcome and $C$ is the
censoring).](causal_survival_obs_indep.pdf){#fig-causalgraph_obs_ind
alt="Illustration of a causal graph in observational survival data with independent censoring (A is the treatment, $X$ the confounding variable and $T$ is the survival time outcome and $C$ is the censoring)"
fig-align="center" width="40%"}


Under Assumption [-@eq-independantcensoring], we saw in @sec-theoryRCT_indc that the Kaplan-Meier estimator could conveniently handle censoring. Building on @eq-kmcond, we can write
$$
S^{(1)}(t) = \bbE\left[\frac{\bbE[I\{A=1,T > t\}|X]}{\bbE[I\{A=1\}|X]} \right]=\bbE\left[\frac{AI\{T > t\}}{e(X)} \right],
$$
which suggests to adapt the classical KM estimator by reweighting it by the propensity score, as detailed below. The use of propensity score in causal
inference has been introduced by @Propensity_causality and extended to
survival analysis by @IPTW. Propensity scores are often estimated using parametric models such as logistic regression but non parametric methods such as probability forests can be used as well. 

::: {#def-iptwkm}
(IPTW Kaplan-Meier estimator)
We let $\wh e(\cdot)$ be an estimator of the propensity score $e(\cdot)$. We introduce

\begin{align*}
D_k^{\mathrm{IPTW}}(a) &:= \sum_{i=1}^n \left(\frac{a}{\wh e(X_i)}+\frac{1-a}{1- \wh e(X_i)}\right)I(\wt T_i = t_k, \Delta_i = 1, A_i=a) \\
\mand N^{\mathrm{IPTW}}_k(a) &:= \sum_{i=1}^n \left(\frac{a}{\wh e(X_i)}+\frac{1-a}{1- \wh e(X_i)}\right) I(\wt T_i \geq t_k, A_i=a),
\end{align*}

be the numbers of deaths and of individual at risk at time $t_k$, reweighted by the propensity score. The IPTW version of the KM estimator is then defined as: 
$$
\begin{aligned}
\wh{S}_{\mathrm{IPTW}}(t | A=a) &= \prod_{t_k \leq t}\left(1-\frac{D_k^{\mathrm{IPTW}}(a)}{N_k^{\mathrm{IPTW}}(a)}\right). 
\end{aligned}
$${#eq-IPTWKM}

:::


<!-- ##### Properties of IPTW Kaplan Meier estimator -->

We let $S^*_{\mathrm{IPTW}}(t | A=a)$ be the oracle KM-estimator defined as above with $\wh e(\cdot) = e(\cdot)$. Although the reweighting slightly changes the analysis, the good properties of the classical KM carry on to this setting. 

::: {#prp-iptwkm}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-independantcensoring] and [-@eq-poscen] The oracle IPTW Kaplan-Meier estimator $S^*_{\mathrm{IPTW}}(t | A=a)$ is a strongly consistent and asymptotically normal estimator of $S^{(a)}(t)$.
:::

The proof of this result simply relies again on the law of large number and the $\delta$-method and can be found in @sec-proof31. Because now $S^*_{\mathrm{IPTW}}$ is a continuous function of $e(\cdot)$, we easily derive the following corollary. 

::: {#cor-iptwkm}
Under the same assumptions as @prp-iptwkm, if $\wh e(\cdot)$ satisfies $\|\wh e-e\|_{\infty} \to 0$ almost surely (resp. in probability), then the IPTW Kaplan-Meier estimator $S_{\mathrm{IPTW}}(t | A=a)$ is a strongly (resp. weakly) consistent estimator of $S^{(a)}(t)$.
:::
The resulting RMST estimator simply takes the formn:
$$
\wh{\theta}_{\mathrm{IPTW-KM}} = \int_{0}^{\tau}\wh{S}_{\mathrm{IPTW}}(t|A=1)-\wh{S}_{\mathrm{IPTW}}(t|A=0)dt.
$$ {#eq-RMST_IPTWKM}
We are not aware of any formal results concerning the bias and the asymptotic variance of the oracle estimator $S^*_{\mathrm{IPTW}}(t | A=a)$.We refer to @IPTW for heuristics concerning these questions. [CB: c'est mieux?]




## Conditional independent censoring {#sec-obscondcens}
Under @eq-unconf (uncounfoundedness) and @eq-condindepcensoring
(conditional independent censoring), the causal effect is affected both
by confounding variables (confounding bias) and by conditional
censoring. The associated causal graph is depicted in  @fig-causalgraph_obs_dep. A very natural approach is to reweight the tranformations previously considered to handle the conditional censoring  by the propensity score to disentangle both effects at the same time.

![Causal graph in observational survival data
with dependent censoring.](causal_survival_obs_dep.pdf){#fig-causalgraph_obs_dep
alt="Illustration of a simple causal graph in observational survival data with independent censoring.](causal_survival_obs_dep.pdf)"
fig-align="center" width="40%"}



### IPTW-IPCW transformations

Inspired by the IPW estimators from causal inference [@hirano2003efficient], one can also reweight the observed time by the inverse of the propensity score in a attempt to remove the confounding effect of the covariates. Building on the IPCW tranformation introduced in @sec-ipcw, we would obtain the so-called IPTW-IPCW tranformation:
$$
T^*_{\mathrm{IPTW-IPCW}} = \left(\frac{A}{e(X)}+\frac{1-A}{1-e(X)} \right) \frac{\Delta^\tau}{G(\wt T \wedge \tau | X,A)} \wt T \wedge \tau. 
$$ {#eq-iptwipcw}

::: {#prp-iptwipcw}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], the IPTW-IPCW transform [-@eq-iptwipcw] is a censoring unbiased transformation in the following sense: for $a \in \{0,1\}$, it holds
$$
\bbE[I\{A=a\} T^*_{\mathrm{IPTW-IPCW}}|X] = \bbE[T(a) \wedge \tau|X].
$$
:::

The proof of @prp-iptwipcw can be found in @sec-proof32. This transform now depends on two nuisance parameters, namely the conditional survival function of the censoring, and the propensity score. Once estimators of these quantities are provided, one could look at
$$
\wh \theta_{\mathrm{IPTW-IPCW}} = \frac1n\sum_{i=1}^n  \left(\frac{A}{\wh e(X)}-\frac{1-A}{1-\wh e(X)} \right)\frac{\Delta_i^\tau}{\wh G(\wt T \wedge \tau | A_i,X_i)} \wt T_i \wedge \tau, \ 
$$ {#eq-thetaiptwipcw}

::: {#prp-consiptwipcw}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], and if $\wh G(\cdot|X,A)$ and $\wh e (\cdot)$ are uniformly weakly (resp. strongly) consistent estimators, then estimator [-@eq-thetaiptwipcw] is a weakly (resp. strongly) consistent estimator of the RMST.
:::

The proof of @prp-consiptwipcw can be found in @sec-proof32. We can also use the same strategy as for the IPCW tranform and incorporate the new weights into a Kaplan-Meier estimator.

::: {#def-iptwipcwkm} 
(IPTW-IPCW-Kaplan-Meier)
We let again $\wh G(\cdot|X,A)$ and $\wh e(\cdot)$ be estimators of the conditional censoring survival function and of the propensity score. We introduce

\begin{align*}
D_k^{\mathrm{IPTW-IPCW}}(a) &:= \sum_{i=1}^n \left(\frac{A_i}{\wh e(X_i)}+\frac{1-A_i}{1-\wh e(X_i)} \right)\frac{\Delta_i^\tau}{\wh G(\wt T_i \wedge\tau | X_i,A=a)} I(\wt T_i = t_k, A_i=a) \\
\mand N^{\mathrm{IPTW-IPCW}}_k(a) &:= \sum_{i=1}^n \left(\frac{A_i}{\wh e(X_i)}+\frac{1-A_i}{1-\wh e(X_i)} \right)\frac{\Delta_i^\tau}{\wh G(\wt T_i \wedge\tau | X_i,A=a)} I(\wt T_i \geq t_k, A_i=a),
\end{align*}

be the weight-corrected numbers of deaths and of individual at risk at time $t_k$. The IPCW version of the KM estimator is then defined as: 
$$
\begin{aligned}
\wh{S}_{\mathrm{IPTW-IPCW}}(t | A=a) &= \prod_{t_k \leq t}\left(1-\frac{D_k^{\mathrm{IPTW-IPCW}}(a)}{N_k^{\mathrm{IPTW-IPCW}}(a)}\right). 
\end{aligned}
$$
:::

The difference in RMST estimated with IPTW-IPCW-Kaplan-Meier survival curves is then simply  as

$$
\wh{\theta}_{\mathrm{IPTW-IPCW}} = \int_{0}^{\tau}\wh{S}_{\mathrm{IPTW-IPCW}}(t|A=1)-\wh{S}_{\mathrm{IPTW-IPCW}}(t|A=0)dt.
$$ {#eq-RMST_IPTW_IPCWKM}

This estimator is consistent, provided that $\wh e$ and $\wh G$ are too.

::: {#prp-iptwipcwkm}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], and for all $t \in [0,\tau]$, if the oracle estimator $S^*_{\mathrm{IPTW-IPCW}}(t | A=a)$ defined as in @def-iptwipcwkm with $\wh G(\cdot|A,X) = G(\cdot|A,X)$ and $\wh e = e$ is a strongly consistent and asymptotically normal estimator of $S^{(a)}(t)$ .
:::

The proof of @prp-iptwipcwkm can be found in @sec-proof32. Under consistency of the estimators of the nuisance parameters, the previous proposition implies that this reweighted Kaplan-Meier is a consistent estimator of the survival curve.

::: {#cor-consiptwipcwkm}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], and for all $t \in [0,\tau]$, if the nuisance estimators $\wh G(\cdot|A,X)$ and $\wh e$ are weakly (resp. strongly) uniformly consistent, then $\wh{S}_{\mathrm{IPTW-IPCW}}(t | A=a)$ is a weakly (resp. strongly) consistent estimator of $S^{(a)}(t)$ .
:::

We are not aware of general formula for the asymptotic variances in this context. We mention nonetheless that @Schaubel2011 have been able to derive asymptotic laws in this framework in the particular case of Cox-models.



### IPTW-BJ transformations

We can also apply IPTW to the Buckley-James transformation introduced in @sec-BJ. We obtain
$$
T^*_{\mathrm{IPTW-BJ}} = \left(\frac{A}{e(X)}+\frac{1-A}{1-e(X)} \right)\left(\Delta^\tau \wt T \wedge \tau + (1-\Delta^\tau) Q_S(\wt T \wedge \tau|A,X)\right). 
$$ {#eq-iptwbj}

::: {#prp-iptwbj}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], the IPTW-BJ transform [-@eq-iptwbj] is a censoring unbiased transformation in the following sense: for $a \in \{0,1\}$, it holds
$$
\bbE[I\{A=a\} T^*_{\mathrm{IPTW-BJ}}|X] = \bbE[T(a) \wedge \tau|X].
$$
:::

The proof of @prp-iptwbj can be found in @sec-proof32. This transform again depends on two nuisance parameters which, once estimated, yields the following estimator of the ATE:
$$
\wh \theta_{\mathrm{IPTW-BJ}} = \frac1n\sum_{i=1}^n  \left(\frac{A}{\wh e(X)}-\frac{1-A}{1-\wh e(X)} \right)\left(\Delta^\tau \wt T \wedge \tau + (1-\Delta^\tau) \wh Q_S(\cdot|A,X)\right),  
$$ {#eq-thetaiptwbj}

::: {#prp-consiptwbj}
Under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], and if $\wh Q_S(\cdot|X,A)$ and $\wh e (\cdot)$ are uniformly weakly (resp. strongly) consistent estimators, then estimator [-@eq-thetaiptwbj] is a weakly (resp. strongly) consistent estimator of the RMST.
:::

The proof of @prp-consiptwbj can be found in @sec-proof32.

### The $G$-formula {#sec-OBS_GF}

Like in @sec-cox, one can estimate the RMST by leveraging @eq-identcond with the  $G$-formula @eq-gformula. 
$$
\wh\theta_{\mathrm{G-formula}}=\frac1n \sum_{i=1}^n \wh \mu(X_i,1)-\wh \mu (X_i,0).
$$

@RMST study this estimator in the particular case where  $\wh\mu_a$ are estimated using Cox models. They are able to show that the resulting estimator is strongly consistence and asymptotically normal, and they give an explicit formulation of the asymptotic variance as a function of the parameters of the Cox model. @Foster_2011 and @Soren_2019 empirically study this estimator using Survival Forest, with the former employing it as a T-learner (referred to as ‘Virtual Twins’) and the latter as an S-learner.


### Double augmented corrections {#sec-AIPTW_AIPCW}

Building on the classical doubly-robust AIPTW estimator from causal inference [@robins1994estimation], we could incorporate the doubly-robust transformations of @sec-tdr to obtain a _quadruply robuts_ tranformation
$$
T^*_{\mathrm{QR}} = T^*_{\mathrm{QR}}(G,S,\mu,e)  := \left(\frac{A}{e(X)}+\frac{1-A}{1-e(X)}\right)(T^*_{\mathrm{DR}}(G,S)-\mu(X,A))+\mu(X,A),
$$
where we recall that $T^*_{\mathrm{DR}}$ is defined in @sec-tdr. This transformations depends on four nuisance parameters: $G$ and $S$ through $T^*_{\mathrm{DR}}$, and now the propensity score $e$ and the conditional response $\mu$. It is easy to show that $T^*_{\mathrm{QR}}$ is quadruply robust in the following sense.

::: {#prp-tqr} 
Let $G,H$ be two conditional survival function, $p$ be a propensity score, and $\nu$ be a conditional response. Then, under the same assumtion on $F,R$ as in @prp-tdr, and under Assumptions [-@eq-sutva;-@eq-unconf;-@eq-positivitytreat;-@eq-condindepcensoring] and [-@eq-positivitycensoring], the transformations $T^*_{\mathrm{QR}} = T^*_{\mathrm{QR}}(F,R,p,\nu)$ satisfies, fro $a \in {0,1}$,
$$
\bbE[I\{A=a\} T^*_\mathrm{QR} |X] = \bbE[T(a)\wedge \tau |X]\quad\text{if}\quad  
\begin{cases} F = G \quad &\text{or}\quad R=S \quad \text{and} \\
p=e \quad &\text{or}\quad \nu=\mu.
\end{cases}
$$
:::
This result is similar to [@Ozenne20_AIPTW_AIPCW, Thm 1], and its proof can be found in @sec-proof32. Based on estimators $(\wh G, \wh S, \wh \mu, \wh e)$ of $(G,S,\mu,e)$, one can then propose the following estimator of the RMST, coined the AIPTW-AIPCW estimator in @Ozenne20_AIPTW_AIPCW:
$$
\begin{aligned}
\wh \theta_{\mathrm{AIPTW-AIPCW}} := \frac1n \sum_{i=1}^n \left(\frac{A_i}{\wh e(X_i)}-\frac{1-A_i}{1-\wh e(X_i)}\right)(T^*_{\mathrm{DR}}(\wh G,\wh S)_i-\wh \mu(X_i,A_i)) + \wh \mu(X_i,1)-\wh\mu(X_i,0).
\end{aligned}
$${#eq-AIPTW_AIPCW}
This estimator enjoys good asymptotic properties under parametric models, as detailed in @Ozenne20_AIPTW_AIPCW.



# Implementation

In this section, we first review the notations and summarize the various estimators and their properties. We then present the packages available for directly computing $\theta_{\mathrm{RMST}}$, specifying the particular settings under which each is applicable, whether for randomized controlled trial (RCT) data, observational data, or certain censoring assumptions. Finally, we provide custom implementations for all estimators, even those already available in existing packages. These manual implementations serve two purposes: first, to make the methods accessible to the community when no existing implementation is available; and second, to facilitate a deeper understanding of the methods by detailing each step, even when a package solution exists.

## Summary of the estimators {#sec-summary}


@tbl-reminder_notations summarizes of the notation used in the previous sections:

| Symbol                      | Description                                                                                                                                                    |
|---------------|---------------------------------------------------------|
| $X$                         | Covariates                                                                                                                                                     |
| $A$                         | Treatment indicator $(A=1$ for treatment, $A=0$ for control$)$                                                                                                 |
| $T$                         | Survival time                                                                                                                                                  |
| $T(1),T(0)$                 | Potential survival time respectively with and without treatment                                                                                                |
| $S^{(1)},S^{(0)}$                   | Potential survival curve $\left( S^{(a)}(t) =\mathbb{P}(T(a) > t) \right)_{a \in \{0,1\}}$ of the potential survival time                                                    |
| $C$                         | Censoring time                                                                                                                                                 |
| $\widetilde{T}$             | Observed time ($T \wedge C$)                                                                                                                                   |
| $\Delta$                    | Censoring status $\mathbb{I}\{T \leq C \}$                                                                                                    |
| $\Delta^{\tau}$             | Censoring status of the restricted time $\mathbb{I}\{\widetilde{T} \geq \tau\} + \mathbb{I} \{\widetilde{T} < \tau \} \cdot \Delta$ |
| $\{t_{1},t_{2},\dots,t_{K}\}$ | Support of the survival time and censoring time distribution                                                                                    |
| $e(x)$                      | Propensity score $\mathbb{E} [A| X = x]$                                                                                                                       |
| $\mu(x,a)$                    | $\mathbb{E}[T \wedge \tau \mid X=x,A=a ]$                                                                                                                      |
| $S(t|a,x)$                  | Conditional survival function, $\bbP(T > t | X=x, A =a)$.                                                                             |
| $G(t|a,x)$                | left-limit of the conditional survival function of the censoring $\bbP(C\geq t|X=x,A=a)$                                                                                   |
| $Q_{S}(t|x,a)$              | $\mathbb{E}[T \wedge \tau \mid X=x,A=a, T \wedge \tau>t]$                                                                                                      |

: Summary of the notations. {#tbl-reminder_notations}


@tbl-nuisance provides an overview of the estimators introduced in this paper, along with the corresponding nuisance parameters needed for their estimation and an overview of their statistical properties in particular regarding their sensitivity to mis-specification of the nuisance parameters. [CB: y'a pas le double robust simple de Rubin et van der Laan?]



\begin{table}
    \centering
    \begin{tabular}{|p{3cm}|p{3cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{2.5cm}|}
    \hline
        Estimator & Context of application & Outcome model & Censoring model & Treatment model & Resistant to nuisance mis-specification  \\ \hline
        \underline{Unadjusted KM} & RCT \& Indep. cens. & ~ & ~ & ~ & ~ \\ \hline
        IPCW-KM & \multirow{2}{4.5cm}{RCT \& Dep. cens.}  & ~ & ($G$) & ~ & No  \\ \cline{1-1} \cline{3-6}
        BJ &  & ($Q_S$) & ~ & ~ & No \\ \hline
        \underline{IPTW-KM} & Obs. \& Indep. cens.  & ~ & ~ & ($e$) & No \\ \hline
        IPCW-IPTW-KM & \multirow{4}{4.5cm}{Obs \& Dep. cens.} & ~ & ($G$) & ($e$) & No \\ \cline{1-1} \cline{3-6}
        \underline{$\mathrm{G}$-$\mathrm{formula}$} &  & ($\mu$) & ~ & ~ &  No \\ \cline{1-1} \cline{3-6}
        IPTW-BJ &  &  ($Q_S$) & ~ &  ($e$) &  No \\ \cline{1-1} \cline{3-6}
        AIPTW-AIPCW &  & ($Q_S$, $\mu$) & ($G$) & ($e$) &  Resistant if outcome model well specified or if censoring and treatment model well specified.\\ \hline
    \end{tabular}
    \caption{Estimators of the difference in RMST and nuisance parameters needed to compute each estimator. Empty boxes indicate that the nuisance parameter is not needed in the estimator thus mis-specification has no impact. Underlined estimators are those implemented in available packages}
    \label{tbl-nuisance}
\end{table}

In the next sections, the following packages will be used. [CB: a mettre en section package? on comprend pas trop ce que ça vient faire la]

```{r packages, warning=FALSE, echo=TRUE, message=FALSE}
library(survival) # Implementation of Kaplan-Meier

library(survRM2)
library(RISCA)
library(grf) # causal_survival_forest function and also 
# survival_forest and probability_forest


library(MASS) # mvrnorm function for simulation
library(rms) # cph function and predict for cph object

library(dplyr)
library(ggplot2)
library(gridExtra) # to plot multiple graph on a page
```


We also use utilitary functions that will be used through the different implementation: 

- \texttt{estimate\_propensity\_score}: function to estimate propensity scores  $e(X)$ using either parametric (i.e. logistic regression with the argument \texttt{"glm"}) or non-parametric methods (i.e. probability forest with the argument \texttt{"probability forest"} based on the \texttt{probability\_forest} function from the [grf ](https:%20//cran.r-project.org/web/packages/grf/index.html)[@Tibshirani_Athey_Sverdrup_Wager_2017] package). This latter can include cross-fitting (n.folds\>1). 

- \texttt{estimate\_survival\_function}: function to estimate the conditional survival model, which supports either Cox models (argument \texttt{type\_of\_model ="cox"}) or survival forests  (argument \texttt{type\_of\_model ="survival forest"})  which uses the function \texttt{survival\_forest} from the [grf ](https:%20//cran.r-project.org/web/packages/grf/index.html)[@Tibshirani_Athey_Sverdrup_Wager_2017] package). This latter can also include cross-fitting (n.folds\>1). The estimation can be done as a single learner (argument \texttt{learner ="S-learner"}) or two learners (argument \texttt{learner ="T-learner"}). 

- \texttt{estimate\_hazard\_function}: function to estimate the instantaneous hazard function by deriving the cumulative hazard function at each time point. This cumulative hazard function is estimated from the negative logarithm of the survival function. 

- \texttt{Q\_t\_hat}: function to estimate the remaining survival function at all time points which uses the previous \texttt{estimate\_survival\_function}. 

- \texttt{Q\_Y}: function to find the remaining survival function from \texttt{Q\_t\_hat} at the specific time to event. [CB: c'est a dire? c'est pas un simple appel de Q t hat?]

- \texttt{integral\_rectangles}: function to estimate the integral of a decreasing step function using the rectangle method with the function's x and y coordinates.

- \texttt{expected\_survival}: function to estimate the integral of a continuous survival function using the trapezoidal method.

- \texttt{integrate}: function to estimate the integral at specific time points \texttt{Y.grid} of a given \texttt{integrand} which takes its values at \texttt{times}.


## Available packages 

Currently, there are few sustained implementations available for estimating RMST in the presence of right censoring. Notable exceptions [CB: exception?] include the packages [survRM2](https:%20//cran.r-project.org/web/packages/survRM2/index.html)
[@SurvRM2_2015][CB:mauvais format biblio], [grf](https:%20//cran.r-project.org/web/packages/grf/index.html) [@Tibshirani_Athey_Sverdrup_Wager_2017] and [RISCA](https://cran.r-project.org/web/packages/RISCA/index.html) [@Foucher_Le_Borgne_Chatton_2019].

[CB: dans toute cette section je pointerais plutot vers les equations definissant estimateurs que vers les assumptions, sinon on a l'impression que qu'on ne peut pas appeler ces fonctions en dehors de ces hypotheses ce qui est faux.]

**SurvRM2**

Under @eq-rta (random treatment assignment) and @eq-independantcensoring (independent
censoring),  the difference in RMST with Unadjusted Kaplan-Meier $\hat \theta_{KM}$ (@eq-unadjKM) can be obtained using the function \texttt{rmst2} which takes as arguments the observed time-to-event, the status, the arm which corresponds to the treatment and $\tau$. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(survRM2)
RMST_survRM2 <- function(data, tau) {
  ATE_pack <- rmst2(data$T_obs, data$status, arm = data$A, tau = tau)
  RMST <- ATE_pack[[5]][1]
  return(RMST)
}
```

[IM: c'est pas claire pour moi si cette fonction $RMST_survRM2$ calcule directement $theta_rmst$ ou les 2 rmst qui correspondent aux deux groupes de traitement. Si elle donne $theta_rmst$, je l'appelerai peut-etre $theta_rmst_survrm2$] [CV : à faire à la fin, à homogénéiser partout]

**RISCA**

The RISCA package provides several methods for estimating $\theta_{\mathrm{RMST}}$. Under the assumptions of random treatment assignment  (@eq-rta) and independent censoring (@eq-independantcensoring), the difference in RMST with Unadjusted Kaplan-Meier $\hat \theta_{KM}$ (@eq-unadjKM) can be derived using  the \texttt{survfit} function from the the survival package [@Therneau_2001] which  estimates Kaplan-Meier survival curves for treated and control groups, and then the \texttt{rmst} function calculates the RMST by integrating these curves, applying the rectangle method (type="s"), which is well-suited for step functions.

```{r}
# Function to estimate RMST using unadjusted Kaplan-Meier
RISCA_unadj <- function(data, 
                        tau) {
  # Fit survival curves using Kaplan-Meier stratified by treatment group
  fit <- survfit(Surv(T_obs, status) ~ A, data = data)
  res <- summary(fit)
  
  # Estimate RMST for treatment group A=1
  RMST_A1 <- rmst(
    times = res$time[as.character(res$strata) == "A=1"],
    surv.rates = res$surv[as.character(res$strata) == "A=1"],
    max.time = tau, 
    type = "s" # for step-function
  )
  
  # Estimate RMST for treatment group A=0
  RMST_A0 <- rmst(
    times = res$time[as.character(res$strata) == "A=0"],
    surv.rates = res$surv[as.character(res$strata) == "A=0"],
    max.time = tau, 
    type = "s" # for step-function
  )
  
  # Estimate ATE as the difference in RMST between groups
  ATE_RISCA_unadj <- RMST_A1 - RMST_A0
  return(ATE_RISCA_unadj)
}
```


Under the assumptions of unconfoundedness (@eq-unconf), treatment positivity (@eq-positivitytreat), and independent censoring (@eq-independantcensoring), IPTW Kaplan-Meier (@eq-IPTWKM) can be applied using the \texttt{ipw.survival} and \texttt{rmst} functions. The ipw.survival function requires user-specified weights (i.e. propensity scores). To streamline this process, we define the \texttt{RISCA\_iptw} function, which combines these steps and utilizes the \texttt{estimate\_propensity\_score} from the \texttt{utilitary.R} file.

```{r}
source("utilitary.R")
# Function to estimate RMST using IPTW Kaplan-Meier
RISCA_iptw <- function(data, 
                       tau, 
                       X.names.propensity, 
                       nuisance_propensity = "glm", 
                       n.folds = NULL) {
  
  # Estimate propensity scores
  e_hat <- estimate_propensity_score(
    data, 
    treatment_covariates = X.names.propensity,
    type_of_model = nuisance_propensity, 
    n.folds = n.folds
  )
  
  # Compute inverse probability weights
  weighted <- (data$A / e_hat) + ((1 - data$A) / (1 - e_hat))
  
  # Fit weighted survival curves
  IPW_pack <- ipw.survival(
    times = data$T_obs, 
    failures = data$status,
    variable = data$A, 
    weights = weighted
  )
  
  # Calculate RMST for treatment group A=1 using weighted survival curve
  RMST_RISCA_A1 <- rmst(
    times = IPW_pack$table.surv$times[IPW_pack$table.surv$variable == 1],
    surv.rates = IPW_pack$table.surv$survival[IPW_pack$table.surv$variable == 1],
    max.time = tau, 
    type = "s"
  )
  
  # Calculate RMST for treatment group A=0 using weighted survival curve
  RMST_RISCA_A0 <- rmst(
    times = IPW_pack$table.surv$times[IPW_pack$table.surv$variable == 0],
    surv.rates = IPW_pack$table.surv$survival[IPW_pack$table.surv$variable == 0],
    max.time = tau, 
    type = "s"
  )
  
  # Compute ATE as the difference in RMST between groups
  ATE_RISCA_IPW <- RMST_RISCA_A1 - RMST_RISCA_A0
  return(ATE_RISCA_IPW)
}
```

    
A single-learner version of the G-formula, as introduced in @sec-cox and @sec-OBS_GF, can be implemented using the \texttt{gc.survival} function. This function requires as input the conditional survival function which should be estimated beforehand with a Cox model via the \texttt{coxph} function from the \texttt{survival} package [@Therneau_2001]. Specifically, the single-learner approach applies a single Cox model incorporating both covariates and treatment, rather than separate models for each treatment arm. We provide a function \texttt{RISCA\_gf} that consolidates these steps.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Function to estimate RMST using single learner G-formula with Cox model
RISCA_gf <- function(data, 
                     tau, 
                     X.names.outcome) {
  
  # Define the outcome formula for the Cox model
  outcome <- paste(c('Surv(', "T_obs", ',', "status", ')'), collapse = "")
  # Single learner : the treatment arm is a predictor
  formula <- as.formula(paste(outcome, paste(c(X.names.outcome, 'A'), 
                                             collapse = " + "), sep = " ~ "))
  
  # Fit the Cox proportional hazards model
  cox.cdt <- coxph(formula, data = data, x = TRUE)
  summary(cox.cdt)
  
  # Compute the effect of the treatment (ATE) using the G-formula
  gc.ate <- gc.survival(
    object = cox.cdt, 
    data = data, 
    group = "A", 
    times = "T_obs",
    failures = "status", 
    max.time = tau, 
    iterations = 100,
    effect = "ATE",
    n.cluster = 1
  )
  
  # Extract the ATE
  ATE_RISCA_gf <- gc.ate$delta[[1]]
  return(ATE_RISCA_gf)
}

```

**grf**

The \texttt{grf} package [@Tibshirani_Athey_Sverdrup_Wager_2017] enables estimation of the difference between RMST using the Causal Survival Forest approach [@HTE_causal_survival_forests], which extends the non-parametric causal forest framework to survival data.
The RMST can be estimated with the \texttt{causal\_survival\_forest} function, requiring covariates $X$, observed event times, event status, treatment assignment, and the time horizon $\tau$ as inputs. The \texttt{average\_treatment\_effect} function then evaluates the treatment effect based on predictions from the fitted forest.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Function to estimate RMST using Causal Survival Random Forest (CSRF)
CSRF <- function(data, X.names, tau) {
  # Fit a causal survival forest
  cf <- causal_survival_forest(X = as.matrix(data[, X.names]), Y = as.matrix(data$T_obs), W = as.matrix(data$A), D = as.matrix(data$status), horizon = tau)
  
  # Predict using the fitted forest
  cf.predict <- predict(cf)
  
  # Estimate the average treatment effect (ATE)
  ATE_csf <- average_treatment_effect(cf)
  
  # Return the estimated ATE
  return(ATE_csf[[1]])
}

```

[CB: mettre toutes les sous-section suivantes dans une seule sous-section et organiser en paragraphe]

## Unadjusted Kaplan-Meier {#sec-implunadjusted}

Although Kaplan-Meier is implemented in the \texttt{survival} package [@Therneau_2001], we provide a custom implementation, \texttt{Kaplan\_meier\_handmade}, for completeness. The difference in Restricted Mean Survival Time, estimated using Kaplan-Meier as in @eq-unadjKM can then be calculated with the \texttt{RMST\_1} function. Here, the integral is computed using the \texttt{integral\_rectangles} utility function, available in the \texttt{utilitary.R} file. [CB: je ne mentionnerais pas du tout ces fonctions utilitaires dans le corps du texte]


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Kaplan-Meier estimator handmade implementation
# The database 'data' must be in the same form as that shown in 
# notation (Table 1) and with the same variable name (status, T_obs) 
Kaplan_meier_handmade <- function(data, 
                                  status = data$status, 
                                  T_obs = data$T_obs) {
  # Sort unique observed times
  Y.grid <- sort(unique(T_obs))
  
  # Initialize vectors for number of events, number at risk, and survival 
  # probability
  d <- rep(NA, length(Y.grid))  # Number of events at time Y.grid[i]
  n <- rep(NA, length(Y.grid))  # Number at risk just before time Y.grid[i]
  S <- rep(NA, length(Y.grid))  # Survival probability at time Y.grid[i]
  
  # Loop over each unique observed time
  for (i in 1:length(Y.grid)) {
    d[i] <- sum(T_obs == Y.grid[i] & status == 1, na.rm = TRUE)  # Count events
    n[i] <- sum(T_obs >= Y.grid[i])  # Count at risk
    
    # Calculate survival probability
    S[i] <- cumprod(1 - d / n)[i]
  }
  
  # Create a data frame with the results
  df <- data.frame(d = d, n = n, S = S, T = Y.grid)
  
  return(df)
}


# Function to calculate RMST (Restricted Mean Survival Time):
# Two possibilities of computing RMST : 
# - in using directly S_A1 and S_A0 (survival function of treated and control)
# - in using the dataframe and the function computes the survival functions
RMST_1 <- function(data = NULL, A1 = 1, A0 = 0, tau, S_A1 = NULL, S_A0 = NULL) {
  if (is.null(S_A1) & is.null(S_A0)) {
    # Subset data for treatment groups
    data1 <- data[data$A == A1,]
    data0 <- data[data$A == A0,]
    
    # Calculate Kaplan-Meier survival estimates
    S_A1 <- Kaplan_meier_handmade(data1, status = data1$status, 
                                  T_obs = data1$T_obs)
    S_A0 <- Kaplan_meier_handmade(data0, status = data0$status, 
                                  T_obs = data0$T_obs)
    
    # Restrict observations to those less than or equal to tau
    Y.grid1 <- data1$T_obs[data1$T_obs <= tau]
    Y.grid0 <- data0$T_obs[data0$T_obs <= tau]
  } else {
    # Restrict observations to those less than or equal to tau
    Y.grid1 <- S_A1$T[S_A1$T <= tau]
    Y.grid0 <- S_A0$T[S_A0$T <= tau]
  }
  
  # Filter survival estimates to restricted observations
  S_A1 <- S_A1 %>%
    dplyr::filter(T %in% Y.grid1)
  S_A0 <- S_A0 %>%
    dplyr::filter(T %in% Y.grid0)
  
  # Check if there is any event at tau for S_A1
  if (!any(S_A1$T == tau)) {
    new_row <- tibble(T = tau, S = S_A1$S[nrow(S_A1)])
    S_A1 <- dplyr::bind_rows(S_A1, new_row)
  }
  
  # Check if there is any event at tau for S_A0
  if (!any(S_A0$T == tau)) {
    new_row <- tibble(T = tau, S = S_A0$S[nrow(S_A0)])
    S_A0 <- dplyr::bind_rows(S_A0, new_row)
  }

  # Calculate integrals from 0 to tau of survival probabilities
  intA1 <- integral_rectangles(S_A1$T, S_A1$S)
  intA0 <- integral_rectangles(S_A0$T, S_A0$S)
  RMST1 <- intA1 - intA0
  
  return(list(RMST=RMST1, intA1=intA1,intA0=intA0))
}

```

As an alternative, one can also use the \texttt{survfit} function in the survival package [@Therneau_2001]  and specify the \texttt{rmean} argument equal to $\tau$ in the corresponding summary function:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Alternative code to estimate Kaplan-Meier estimator with survival package
# instead of handmade KM
RMST_alternative <- function(data, A1 = 1, A0 = 0, tau){
  # Estimate Kaplan-Meier estimator with survfit function on data subset 
  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,])  # Groupe A = 0
  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,])  # Groupe A = 1

  # Estimate the RMST with rmean
  summary_fit0 <- summary(fit0, rmean = tau)  # RMST pour A = 0
  summary_fit1 <- summary(fit1, rmean = tau)  # RMST pour A = 1

  # Extraire les RMST des résultats
  rmst0 <- summary_fit0$table["rmean"][[1]]
  rmst1 <- summary_fit1$table["rmean"][[1]]

  # Calculer la différence des RMST entre les deux groupes
  difference_rmst <- rmst1 - rmst0
return(difference_rmst)
}
```


## IPCW Kaplan-Meier {#sec-implIPCW}

We provide a customized function, \texttt{adjusted.KM}, to facilitate the understanding of the IPCW Kaplan-Meier approach. The difference in RMST, estimated with $\hat{\theta}_{\mathrm{IPCW}}$ as in @eq-thetaIPCWKM, can then be calculated using the \texttt{IPCW\_Kaplan\_meier} function. The survival censoring function $G(t|X)$ is computed with the \texttt{estimate\_survival\_function} utility function from the \texttt{utilitary.R} file.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Kaplan-Meier adjusted
# Times of event 
# Failures:  1 if event, 0 if censored
# Variable:  1 if treated, 0 if control
# Weights:  Weight of the individual
adjusted.KM <- function(times, failures, variable, weights = NULL) {
  # Sanity checks
  if (sum(times < 0) > 0) {
    stop("Error: times must be positive")
  }
  if (!is.null(weights) && sum(weights < 0, na.rm = TRUE) > 0) {
    stop("Error: weights must be superior to 0")
  }
  if (sum(failures != 0 & failures != 1) > 0) {
    stop("Error: failures must be a vector of 0 or 1")
  }
  # If 'weights' is NULL, initialize 'w' with ones of the same length as 'times', 
  # otherwise use 'weights'
  w <- if (is.null(weights)) rep(1, length(times)) else weights
  
  # Create a DataFrame 'data' with columns t (times), f (failures), 
  # v (stratification variable: often treatment variable), and w (weights)
  data <- data.frame(t = times, f = failures, v = variable, w = w)
  
  # Remove rows from the DataFrame where the stratification variable is NA
  data <- data[!is.na(data$v),]
  
  # Initialize an empty DataFrame to store the Kaplan-Meier results
  table_KM <- data.frame(times = NULL, n.risk = NULL, n.event = NULL, 
                         survival = NULL, variable = NULL)
  
  # Loop over each unique value of the stratification variable
  for (i in unique(variable)) {
    # Subset the data for the current stratification variable value
    d <- data[data$v == i,]
    
    # Create a sorted vector of unique event times, including time 0 and the 
    # maximum time
    tj <- c(0, sort(unique(d$t[d$f == 1])), max(d$t))
    
    # Calculate the number of events at each time point
    dj <- sapply(tj, function(x) {
      sum(d$w[d$t == x & d$f == 1])
    })
    
    # Calculate the number of individuals at risk at each time point
    nj <- sapply(tj, function(x) {
      sum(d$w[d$t >= x])
    })
    
    # Compute the cumulative product for the survival probabilities
    st <- cumprod((nj - dj) / nj)
    
    # Append the results to the Kaplan-Meier table
    table_KM <- rbind(table_KM, data.frame(T = tj, n = nj, d = dj, 
                                           S = st, variable = i))
  }
  return(table_KM)
}


# IPCW Kaplan-Meier estimator with restricted tau
IPCW_Kaplan_meier <- function(data, tau, 
                              X.names.censoring, 
                              nuisance_censoring = "cox", 
                              n.folds = NULL) {
  
  # Compute of truncated T_obs, status and censored status
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | 
                                             (data$T_obs < tau & data$status == 1))
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                  (data$T_obs < tau & data$status == 1))
  Y.grid <- sort(unique(data$T_obs_tau))
  
  # Estimate probability of remaining uncensored based on nuisance model 
  S_C_hat <- estimate_survival_function(data = data, X.names = X.names.censoring,
                                        Y.grid = Y.grid, T_obs = "T_obs_tau",
                                        status = "censor.status_tau",
                                        type_of_model = nuisance_censoring,
                                        n.folds = n.folds)
  
  # Select the probability of censoring for each observe T_obs_tau from the all
  # curve
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]
  
  # Compute IPC weights
  data$weights <- data$status_tau / data$S_C
  
  # Compute the adjusted IPCW Kaplan Meier
  S <- adjusted.KM(times = data$T_obs, failures = data$status, 
                   variable = data$A, weights = data$weights)

  # Compute difference in RMST 
  RMST <- RMST_1(S_A1 = S[S$variable == 1,], S_A0 = S[S$variable == 0,], tau = tau)
  
  return(list(RMST = RMST$RMST,
              intA1 = RMST$intA1,
              intA0 = RMST$intA0,
              weights = data$weights))
}

```

One could also use the \texttt{survfit} function in the survival package [@Therneau_2001] in adding IPCW weights for treated and control group and specify the \texttt{rmean} argument equal to $\tau$ in the corresponding summary function:


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Alternative code to estimate IPCW Kaplan-Meier, IPTW Kaplan-Meier or 
# IPTW-IPCW Kaplan Meier estimator with survival package instead of using 
# handmade adjusted.KM function (the weights need to be calculated before).

# Weights0 corresponds to weights of the control and weights1 of treated
Adjusted_Kaplan_meier_alternative <- function(data, A1 = 1, A0 = 0, tau, 
                                          weights0, weights1){
  # Estimate Kaplan-Meier estimator with survfit function on data subset 
  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,], weights = weights0)  # Groupe A = 0
  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,], weights = weights1)  # Groupe A = 1

  # Estimate the RMST with rmean
  summary_fit0 <- summary(fit0, rmean = tau)  # RMST pour A = 0
  summary_fit1 <- summary(fit1, rmean = tau)  # RMST pour A = 1

  # Extraire les RMST des résultats
  rmst0 <- summary_fit0$table["rmean"][[1]]
  rmst1 <- summary_fit1$table["rmean"][[1]]

  # Calculer la différence des RMST entre les deux groupes
  difference_rmst <- rmst1 - rmst0
return(difference_rmst)
}
```

This alternative approach for IPCW Kaplan-Meier would also be valid for IPTW and IPTW-IPCW Kaplan-Meier.

## Buckley-James based estimator {#sec-implBJ}

The function \texttt{BJ} estimates $\theta_{\mathrm{RMST}}$ by implementing the Buckley-James estimator as in @eq-BJ. It uses two functions available in the \texttt{utilitary.R} file, namely \texttt{Q\_t\_hat} and \texttt{Q\_Y}.

<!-- -   \texttt{Q\_t\_hat} which computes $Q_S(t|x,a)$ presented in @eq-defbj for each time point and individuals and uses the \texttt{estimate\_survival\_function} also from the \texttt{utilitary.R} file to estimate the extrapolated time-to-event values of censored observation -->
<!-- -  and \texttt{Q\_Y} which computes specifically $Q_S(T_i \wedge \tau|X_i,A_i)$. -->

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Compute the Restricted Mean Survival Time (RMST) difference
BJ <- function(data, tau, X.names.outcome = c("X1", "X2", "X3", "X4"),
               nuisance = "cox", n.folds = NULL) {
  # Truncate observed times at tau
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  Y.grid <- sort(unique(data$T_obs_tau))
  
  # Censoring status at tau
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                (data$T_obs < tau & data$status == 1))
  
  # Compute Q_t for all time points
  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)
  data$Q_y <- Q_Y(data, tau, Q_t)
  
  # Split data by treatment group
  data_treated <- data %>% dplyr::filter(A == 1)
  data_not_treated <- data %>% dplyr::filter(A == 0)
  
  # Calculate Restricted Survival Time (RST) for each group
  data_treated$RST <- data_treated$status_tau * data_treated$T_obs_tau + 
                      (1 - data_treated$status_tau) * data_treated$Q_y
  
  data_not_treated$RST <- data_not_treated$status_tau * data_not_treated$T_obs_tau + 
                          (1 - data_not_treated$status_tau) * data_not_treated$Q_y
  
  # Calculate RMST (Restricted Mean Survival Time) difference between 
  # treated and not treated
  RMST <- mean(data_treated$RST) - mean(data_not_treated$RST)
  
  # Return RMST and other relevant metrics
  return(list(
    RMST = RMST, 
    ATE_treated = mean(data_treated$RST), 
    ATE_not_treated = mean(data_not_treated$RST)
  ))
}
```

## IPTW Kaplan-Meier {#sec-implIPTW}

The function \texttt{IPTW\_Kaplan\_meier} implements the IPTW-KM estimator in @eq-RMST_IPTWKM. It uses the \texttt{estimate\_propensity\_score} function from the \texttt{utilitary.R}. 


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Function to calculate IPTW Kaplan-Meier
IPTW_Kaplan_meier <- function(data, tau, X.names.propensity, 
                              nuisance_propensity = "glm", n.folds = NULL) {
  # Estimate propensity scores
  data$e_hat <- estimate_propensity_score(
    data,
    treatment_covariates = X.names.propensity,
    type_of_model = nuisance_propensity,
    n.folds = n.folds)
  
  # Truncate observed times at tau
  data$T_obs_tau <- pmin(data$T_obs, tau)
  
  # Define censoring status at tau
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                (data$T_obs < tau & data$status == 1))
  
  # Calculate weights
  data$weights <- (data$A) * (1 / data$e_hat) + (1 - data$A) / (1 - data$e_hat)
  
  # Adjusted Kaplan-Meier estimator
  S <- adjusted.KM(
    times = data$T_obs, 
    failures = data$status,
    variable = data$A, 
    weights = data$weights)
  
  # Calculate RMST from the adjusted survival curves
  RMST <- RMST_1(S_A1 = S[S$variable == 1,], 
                 S_A0 = S[S$variable == 0,], 
                 tau = tau)
  
  return(list("intA0" = RMST$intA0, "intA1" = RMST$intA1, "RMST" = RMST$RMST))
}

```

## G-formula {#sec-implGf}
[CV : J'ai reduit le code, ça va modifier le texte :][CV: attention j'ai changé aussi légèrement estimate_survival_function]
We implement two versions of the G-formula: \texttt{g\_formula\_T\_learner} and \texttt{g\_formula\_S\_learner}. In \texttt{g\_formula\_T\_learner}, separate models estimate survival curves for treated and control groups, whereas \texttt{g\_formula\_S\_learner} uses a single model incorporating both covariates and treatment status to estimate survival time. The latter approach is also available in the RISCA package but is limited to Cox models.

Our nuisance models include both survival forests and Cox regression,
[CB: a supprimer IMO -->]
with cross-fitting applied to survival forests when \texttt{n.folds} > 1. Integration is handled by the trapezoidal rule (detailed in appendix @sec-trapez), implemented through the \texttt{Expected\_survival} utility function in \texttt{utilitary.R}. The function \texttt{cph} from [rms](https://cran.r-project.org/web/packages/rms/index.html)  function from the rms package is preferred because it allows for predictions on a specified time scale, a feature that the \texttt{coxph} from [survival](https://cran.r-project.org/web/packages/survival/index.html) does not support.
[CB: <--]

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Function to estimate the g-formula Two-learner.
g_formula_T_learner <- function(data, 
                                X.names.outcome, 
                                tau, 
                                nuisance_survival = "cox", 
                                n.folds = NULL) {
  # Compute min(T_obs,tau)
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  
  # Y.grid is the grid of time points where we want to estimate the 
  # survival function.
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_hat <- estimate_survival_function(data, X.names.outcome, 
                                      Y.grid, 
                                      type_of_model = nuisance_survival,
                                      T_obs = "T_obs", 
                                      status = "status", 
                                      n.folds = n.folds)
  
  # Compute the area under each survival curve until max(Y.grid) = tau.
  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)
  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)
  
  # Calculate the mean difference.
  theta_g_formula <- mean(E_hat1 - E_hat0)
  
  return(theta_g_formula)
}

# Function to estimate the g-formula Single-learner.
g_formula_S_learner <- function(data, 
                                X.names.outcome, 
                                tau, 
                                nuisance_survival = "cox", 
                                n.folds = NULL) {
  # Compute min(T_obs,tau)
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  
  # Y.grid is the grid of time points where we want to estimate the 
  # survival function.
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_hat <- estimate_survival_function(data, X.names.outcome, 
                                      Y.grid, 
                                      type_of_model = nuisance_survival,
                                      learner = "S-learner",
                                      T_obs = "T_obs", 
                                      status = "status", 
                                      n.folds = n.folds)
  
  # Compute the area under each survival curve until max(Y.grid) = tau.
  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)
  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)
  
  # Calculate the mean difference.
  theta_g_formula <- mean(E_hat1 - E_hat0)
  
  return(theta_g_formula)
}

```

## IPTW-IPCW Kaplan-Meier {#sec-IPTW_IPCW_KM}

The \texttt{IPTW\_IPCW\_Kaplan\_meier} function implements the IPTW-IPCW Kaplan Meier estimator from @eq-RMST_IPTW_IPCWKM. It uses the  utilitary functions from the \texttt{utilitary.R} file \texttt{estimate\_propensity\_score} and \texttt{estimate\_survival\_function} to estimate the nuisance parameters, and the function \texttt{adjusted.KM} (detailed and implemented in @sec-implIPCW) which computes an adjusted Kaplan Meier estimator using the appropriate weight.

```{r echo=TRUE, message=FALSE, warning=FALSE}
IPTW_IPCW_Kaplan_meier <- function(data, 
                                   X.names.propensity, 
                                   X.names.censoring, 
                                   tau,
                                   nuisance_propensity = "glm",
                                   nuisance_censoring = "cox",
                                   n.folds = NULL) {
  # Censoring time to tau if observed time exceeds tau
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  
  # Create censoring status for tau
  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | 
                                           (data$T_obs < tau & data$status == 1))
  
  # Create status at tau
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                (data$T_obs < tau & data$status == 1))
  
  # Grid of unique observed times truncated at tau
  Y.grid <- sort(unique(data$T_obs_tau))

  # Estimate propensity scores
  data$e_hat <- estimate_propensity_score(data,
                                          treatment_covariates = X.names.propensity,
                                          type_of_model = nuisance_propensity,
                                          n.folds = n.folds)

  # Estimate survival function for censoring
  S_C_hat <- estimate_survival_function(data, X.names = X.names.censoring,
                                        Y.grid = Y.grid, T_obs = "T_obs_tau",
                                        status = "censor.status_tau",
                                        type_of_model = nuisance_censoring,
                                        n.folds = n.folds)

  # Get estimated survival probabilities for censoring
  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]

  # Calculate weights
  data$weights <- data$status_tau / data$S_C * 
                  (data$A * (1 / data$e_hat) + 
                     (1 - data$A) * (1 / (1 - data$e_hat)))

  # Compute adjusted Kaplan-Meier estimator
  S <- adjusted.KM(times = data$T_obs_tau, 
                   failures = data$status_tau, 
                   variable = data$A, 
                   weights = data$weights)

  # Compute Restricted Mean Survival Time (RMST)
  RMST <- RMST_1(S_A1 = S[S$variable == 1, ], 
                 S_A0 = S[S$variable == 0, ],
                 tau = tau)

  # Return RMST and ATE for treated and not treated groups
  return(list(RMST = RMST$RMST, ATE_treated = RMST$intA1, 
              ATE_not_treated = RMST$intA0))
}

```

## IPTW-BJ estimator {#sec-IPTW_BJ_impl}

The \texttt{IPTW\_BJ} implements the IPTW-BJ estimator in @eq-thetaiptwbj. It uses the  utilitary functions, from the \texttt{utilitary.R} file, \texttt{estimate\_propensity\_score} to estimate the nuisance parameters. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
# In using the min
IPTW_BJ <- function(data, 
                    X.names.propensity,
                    X.names.outcome, 
                    tau,
                    nuisance_propensity = "glm",
                    nuisance = "cox",
                    n.folds = NULL) {
  # Minimum of T_obs and tau
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  
  # Grid of unique observed times truncated at tau
  Y.grid <- sort(unique(data$T_obs_tau))
  
  # Indicator for min(T, tau) < C
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                (data$T_obs < tau & data$status == 1))
  

  # Estimate propensity scores
  data$e_hat <- estimate_propensity_score(data,
                                          treatment_covariates = X.names.propensity,
                                          type_of_model = nuisance_propensity,
                                          n.folds = n.folds)


  # Estimation of Q_s
  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)
  data$Q_y <-  Q_Y(data,tau,Q_t)
  
  # BJ transformation
  data$Y <-  data$status_tau * data$T_obs_tau + 
                             (1 - data$status_tau) * data$Q_y
  
  # IPTW on BJ transformation 
  data$RST <- data$Y * (data$A/data$e_hat-(1-data$A)/(1-data$e_hat))
  
  RMST <- mean(data$RST)
  
  # Return RMST and other relevant metrics
  return(RMST)
}
```

## AIPTW-AIPCW 

The \texttt{AIPTW\_AIPCW} function implements the AIPTW_AIPCW estimator @eq-AIPTW_AIPCW using the utilitary function from the \texttt{utilitary.R} file \texttt{estimate\_propensity\_score} to estimate the nuisance parameters. 
<!-- Then, the AIPCW weights are estimated using the \texttt{AIPCW} function which uses \texttt{estimate\_survival\_function} for the censoring,  \texttt{Q\_t\_hat} and \texttt{Q\_Y} functions, the \texttt{Estimate\_hazard\_function} which computes the instantaneous hazard function of the corresponding survival function. This function compute the instantaneous hazard function as a forward difference of $-\log \left(\hat{S}(t \mid x)\right)$ and \texttt{Integrate} which integrate from 0 to $T_i \wedge \tau$ for each individuals the integrand function. Both are necessary to compute the third term of AIPCW (in @eq-TDR). -->


```{r echo=TRUE, message=FALSE, warning=FALSE}
# DR censoring transformation
AIPCW <-function(data,
                 tau,
                 X.names.censoring = c("X1","X2","X3","X4"),
                 X.names.outcome = c("X1","X2","X3","X4"),
                 nuisance_Qt = "cox",
                 nuisance_censoring = "cox", 
                 n.folds = NULL, 
                 h_C_hat = NULL,
                 method_aipw = 1) {
  
  # Truncate observed times at tau
  data$T_obs_tau <- pmin(data$T_obs, tau)
  
  # Define status at tau
  data$status_tau <-  as.numeric((data$T_obs > tau) | 
                                  (data$T_obs <= tau &  data$status == 1 ))  

  data$censor.status_tau <- 1- as.numeric(
    (data$T_obs > tau) | (data$T_obs <= tau &  data$status == 1 ))
 
  Y.grid <- sort(unique(data$T_obs_tau))
  
  # Estimate survival function for censoring
  S_C_hat <- estimate_survival_function(data = data,X.names.censoring,
                                        type_of_model = nuisance_censoring,
                                        n.folds = n.folds,
                                        Y.grid = Y.grid,
                                        T_obs = "T_obs_tau",
                                        status = "censor.status_tau")
  
  Y.index <- findInterval(data$T_obs_tau, Y.grid)
  
  data$S_C_hat_T_obs_tau <- S_C_hat$S_hat[cbind(seq_along(Y.index), Y.index)]

  
  if (is.null(h_C_hat)) {
      h_C_hat <- estimate_hazard_function(S_C_hat$S_hat,Y.grid)
  } 
  
  # Compute Q.t.hat
  Q.t.hat <- Q_t_hat(data = data,
                     X.names = X.names.outcome,
                     tau = tau,
                     nuisance = nuisance_Qt,
                     n.folds = n.folds)
  
  # Compute Q.Y.hat
  data$Q.Y.hat <- Q_Y(data = data, tau, Q.t.hat)

  # Compute first term
  data$first_term <- (data$T_obs_tau * data$status_tau) / 
    data$S_C_hat_T_obs_tau
  
  # Compute second term
  data$second_term <- (data$Q.Y.hat * (1 - data$status_tau)) / 
    data$S_C_hat_T_obs_tau
  
  Y.diff <- diff(c(0, Y.grid))
  
  # Compute integrand for the third term
  integrand <- sweep( ( (h_C_hat) / S_C_hat$S_hat )* (Q.t.hat), 2, Y.diff, "*")
  
  # Compute third term
  data$third_term <- integrate(integrand, Y.grid, data$T_obs_tau)
  
  # Compute pseudo outcome
  pseudo_outcome <- data$first_term + data$second_term - data$third_term

  return(pseudo_outcome) 
}


AIPTW_AIPCW <- function(data, 
                        tau, 
                        X.names.propensity = c("X1", "X2", "X3", "X4"),
                        X.names.censoring = c("X1", "X2", "X3", "X4"),
                        X.names.outcome = c("X1", "X2", "X3", "X4"),
                        nuisance_propensity = "glm",
                        nuisance_regression = "cox",
                        nuisance_censoring = "cox",
                        nuisance_Qt = "cox",
                        n.folds = NULL) {
  
  # Estimate propensity scores
  data$e_hat <- estimate_propensity_score(
    data = data, 
    treatment_covariates = X.names.propensity, 
    type_of_model = nuisance_propensity, 
    n.folds = n.folds
  )
  
  # Prepare data for censoring model
  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)
  
  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | 
                                             (data$T_obs < tau & data$status == 1))
  
  data$status_tau <- as.numeric((data$T_obs >= tau) | 
                                  (data$T_obs < tau & data$status == 1))
  
  # Create unique time grid
  Y.grid <- sort(unique(data$T_obs_tau))
  
  S_hat <- estimate_survival_function(data, X.names.outcome, 
                                      type_of_model = nuisance_regression, 
                                      Y.grid = Y.grid,
                                      T_obs= "T_obs", 
                                      status = "status", 
                                      n.folds = n.folds)
  
  # Compute area under the survival curve up to tau
  data$E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)
  data$E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)
  
  # Compute IPW-weighted residuals
  data$IPW_res <- data$E_hat1 * (1 - data$A / data$e_hat) - 
    data$E_hat0 * (1 - (1 - data$A) / (1 - data$e_hat))
  
  # Compute AIPCW weights
  TDR <- AIPCW(
    data = data, 
    tau = tau,
    X.names.censoring = X.names.censoring,
    X.names.outcome = X.names.outcome,
    nuisance_Qt = nuisance_Qt, 
    nuisance_censoring = nuisance_censoring, 
    n.folds = n.folds
  )
  
  data$TDR <- TDR
  
  # Compute AIPCW-weighted residuals
  data$AIPCW_w <- data$TDR * (data$A / data$e_hat - 
                                (1 - data$A) / (1 - data$e_hat))
  
  # Compute regression residuals
  data$reg <- data$E_hat1 - data$E_hat0
  data$reg_res <- data$A / data$e_hat * (data$TDR - data$E_hat1) - 
    (1 - data$A) / (1 - data$e_hat) * (data$TDR - data$E_hat0)
  
  # Compute estimators
  # na.rm = TRUE to remove NA for the mean calculation
  AIPTW_AIPCW_IPW_res <- mean(data$AIPCW_w + data$IPW_res, na.rm = TRUE)
  AIPTW_AIPCW_reg_res <- mean(data$reg + data$reg_res, na.rm = TRUE)
  
  return(list(AIPTW_AIPCW_reg_res = AIPTW_AIPCW_reg_res, 
              AIPTW_AIPCW_IPW_res = AIPTW_AIPCW_IPW_res))
}

```


# Simulations {#sec-simulation}

We compare the behaviors and performances of the estimators using simulations. [CB: a supprimer ou a étoffer]
[CB: remarque general: ce serait pas mal de continuer le labelling Scenario 1/2/3/... etc pour faciliter la lecture. Il est present en section 5.1 mais plus dans la suite.]


## RCT {#sec-simulation-RCT}

### Data Generating Process

We generate RCTs with independent censoring (Scenario 1) and 
conditionally independent censoring (Scenario 2).
The survival time and the censoring time (when there is dependency
between the censoring time and the covariates) is simulated using the
cumulative hazard inversion method for exponential models [@Leemis_1990; @Bender_2005]. More specifically,  $n$ samples $(X_{i},A_{i},C,T_{i}(0), T_{i}(1))$ are
generated as follows: [CB: je reformulerais en terme de $S,G$ plutot qu avec les fonctions de hasard instantannee]

-   $X \sim \mathcal{N}\left(\mu=[1,1,-1,1]^{\top}, \Sigma=I_4\right)$.

-   $e(X)=P(A=1|X)=0.5$.

-   $\lambda(0)(X)=0.01 \cdot \exp \left\{0.5 X_1+0.5 X_2-0.5 X_3+0.5 X_4\right\}$
    hazard for the event time $T(0)$.

-   The hazard for the censoring time $C$:

    -   For Scenario 1: $\lambda_c=0.03$ does not depend on covariates.

    -   For Scenario 2:
        $\lambda_c(X)=0.03 \cdot \exp \left\{0.7 X_1+0.3 X_2-0.25 X_3-0.1 X_4-0.2 A\right\}$.

-   $T(1)=T(0)+10$.

-   the survival time is $T=A T(1)+(1-A) T(0)$.

-   The observed time is $\widetilde{T}=\min (T, C)$.

-   The status is $\Delta=1(T \leq C)$.

-   The threshold time $\tau$ is set to 25.

The observed samples are $(X_{i},A_{i},\Delta_{i},\widetilde{T_{i}})$.

```{r echo=TRUE, message=FALSE, warning=FALSE}
############ RCT 
# RCT1:  Random treatment assignment + independent censoring
# RCT2:  Random treatment assignment + dependent censoring (conditional on X 
# and A)
simulate_data_RCT <- function(n, mu = c(1, 1, -1, 1), 
                              sigma = diag(4), 
                              colnames_cov = c("X1", "X2", "X3", "X4"),
                              tau, 
                              coefT0 = 0.01,
                              parsS = c(0.5, 0.5, -0.5, 0.5), 
                              coefC = 0.03,
                              parsC = c(0.7, 0.3, -0.25, -0.1), 
                              parsC_A = c(-0.2), 
                              scenario = "RCT2",
                              mis_specification="none") {
  
  # Generate X from a multivariate normal distribution
  X <- MASS::mvrnorm(n, mu, sigma)
  X <- as.data.frame(X)
  colnames(X) <- colnames_cov
  
  # Treatment variable selection: all X
  X_treatment <- as.matrix(X)
  
  # Propensity score: constant for random assignment
  e <- rep(0.5, n)
  
  # Random treatment assignment
  A <- sapply(e, FUN = function(p) rbinom(1, 1, p))
  
  # Outcome variable selection: all X
  X_outcome <- as.matrix(X)
  
  # Simulate the outcome using the cumulative hazard inversion method
  epsilon <- runif(n, min = 1e-8, max = 1)
  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))
  
  if (scenario == "RCT1") {
    # Simulate independent censoring time
    epsilon <- runif(n, min = 1e-8, max = 1)
    C <- -log(epsilon) / coefC
  }
  else if (scenario == "RCT2") {
    # Simulate dependent censoring time
    X_censoring <- as.matrix(cbind(X,A))
    parsC <- c(parsC,parsC_A)
    
    epsilon <- runif(n, min = 1e-8, max = 1)
    C <- -log(epsilon) / (coefC * exp(rowSums(X_censoring %*% diag(parsC))))
  }
  # T(1) = T(0) + 10
  T1 <- T0 + 10
  
  # True survival time
  T_true <- A * T1 + (1 - A) * T0
  
  # Observed time
  T_obs <- pmin(T_true, C)
  
  # Status indicator
  status <- as.numeric(T_true <= C)
  censor.status <- as.numeric(T_true > C)
  
  # Restricted survival time
  T_obs_tau <- pmin(T_obs, tau)
  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))
  
  # Combine all data into a single data frame
  data_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, 
                                       status, censor.status, status_tau, e)
  
  return(data_target_population)
}

```

The descriptive statistics of the two datasets are displayed in Annex (@sec-stat_RCT).

<!-- $\theta_{\mathrm{RMST}}$ is a time-dependent value. Therefore, the ground truth -->
<!-- for $\theta_{\mathrm{RMST}}$ must be calculated at the required restricted time.  -->
The following implementation provides the value of $\theta_{\mathrm{RMST}}$ for a given time horizon $\tau$. Note that this value is the same for Scenario 1 and Scenario 2. The graph of the difference in RMST as a function of $\tau$ for both Scenarii is displayed below. [CB: je ne m'y connais pas en R donc je vous laisse modifier le code pour qu'il n'y qu'un graphe + changer le titre]

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Function to calculate ground truth for RCT and Observational data
ground_truth <- function(tau, 
                         data) {
  # Compute RMST with the true T1
  data$T1_tau <- ifelse(data$T1 >= tau, tau, data$T1)
  
  # Compute RMST with the true T0
  data$T0_tau <- ifelse(data$T0 >= tau, tau, data$T0)
  
  # Compute the difference in RMST if everyone had the treatment 
  # and if everyone had the control
  truth <- mean(data$T1_tau) - mean(data$T0_tau)
  
  return(truth)
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Set initial tau value
tau <- 25
# Define vector of tau values
vec_tau <- seq(1, 150, by = 1)

# Function to plot the ground truth RMST for different scenarios
plot_ground_truth <- function(data, vec_tau, tau, ylim, title_text) {
  truth <- sapply(vec_tau, function(x) ground_truth(tau = x, data))
  matplot(
    vec_tau, truth, type = "l", lty = 1, col = 1,
    ylab = "RMST", xlab = "tau", ylim = ylim
  )
  abline(v = tau, col = "red", lty = 2)
  abline(h = truth[vec_tau == tau], col = "red", lty = 2)
  title(title_text, cex.main = 0.9)  # Adjusting title text size
}

# Simulation for scenario RCT1
data_RCT1 <- simulate_data_RCT(
  n = 100000, tau = tau, scenario = "RCT1")

plot_ground_truth(data_RCT1, 
                  vec_tau, 
                  tau, 
                  c(0, 10), 
                  "True difference in RMST for RCT scenario 1")

truth_tau1 <- ground_truth(data_RCT1, tau = 25)
print(paste0("The ground truth for RCT scenario 1 at time 25 is ", round(truth_tau1, 1)))

# Simulation for scenario RCT2 with specific coefficients and parameters
data_RCT2 <- simulate_data_RCT(
  n = 100000, tau = tau, scenario = "RCT2", 
  coefC = 0.03, parsC = c(0.7, 0.3, -0.25, -0.1), parsC_A = c(-0.2)
)

plot_ground_truth(data_RCT2, 
                  vec_tau, 
                  tau, 
                  c(0, 10),
                  "True difference in RMST for RCT scenario 2")

truth_tau2 <- ground_truth(data_RCT2, tau = 25)
print(paste0("The ground truth for RCT scenario 2 at time 25 is ", round(truth_tau2, 1)))

```


### Estimation of the RMST

For each setting, we estimate the difference in RMST using the following methods. In parentheses, we indicate how the nuisance components are estimated. Default tuning parameters are applied for forest-based methods, and cross-fitting is performed with five folds. Where available, we use package implementations. [CB: on comprends pas trop ce que ça vient faire la puisqu'on utilise les memes estimateurs dans le cas obs. Je mettrais ça soit en fin de partie implementation, soit en preambule de la partie simulation][CB: de plus j'enleverai NAIVE car on en a jamais parler avant]

[IM : rajouter le nom des fonctions utilisées + argument ][CB: oui pk pas]
\begin{itemize}
    \item \textbf{Naive}: The Naive estimator excludes censored observations and directly applies the $\theta_{\mathrm{RMST}}$ formula to uncensored data.
        \item \textbf{SurvRM2 - KM}: Using the SurvRM2 package for Kaplan-Meier estimation.
        \item \textbf{IPTW KM (Logistic Regression)}: Inverse Probability of Treatment Weighting (IPTW) with Kaplan-Meier, using logistic regression for treatment assignment.
        \item \textbf{RISCA - IPTW KM}: IPTW with Kaplan-Meier implemented through the RISCA package.
        \item \textbf{IPCW KM (Cox)}: Inverse Probability of Censoring Weighting (IPCW) with Kaplan-Meier, using a Cox model for censoring.
          \item \textbf{IPTW-IPCW KM (Cox \& Logistic Regression)}: Combination of IPTW and IPCW with Kaplan-Meier, using a Cox model for censoring and logistic regression for treatment assignment.
          \item \textbf{BJ (Cox)}: Buckley-James estimator with a Cox model.
        \item \textbf{IPTW-BJ (Cox \& Logistic Regression)}: IPTW applied to the Buckley-James estimator, using a Cox model for censoring and logistic regression for treatment assignment.
        \item \textbf{G\_formula (Cox / T-learners)}: G-formula with a Cox model using T-learners.
        \item \textbf{G\_formula (Cox / S-learner)}: G-formula with a Cox model using an S-learner.
        \item \textbf{RISCA - G\_formula (S-learner)}: G-formula implemented through the RISCA package using an S-learner.
         \item \textbf{AIPTW-AIPCW (Cox \& Logistic Regression)}: Augmented IPTW and IPCW estimator using Cox regression for censoring and logistic regression for treatment assignment.
          \item \textbf{grf - Causal Survival Forest}: Generalized random forest-based causal survival estimator.
        \item \textbf{IPTW KM (Forest)}: IPTW applied to Kaplan-Meier estimation, using a forest model for treatment assignment.
        \item \textbf{IPCW KM (Forest)}: IPCW applied to Kaplan-Meier estimation, using a forest model for censoring.
        \item \textbf{BJ (Forest)}: Buckley-James estimator using a forest model.
        \item \textbf{IPTW-BJ (Forest)}: IPTW applied to the Buckley-James estimator, using a forest model for treatment assignment and censoring.
        \item \textbf{IPTW-IPCW KM (Forest)}: Combination of IPTW and IPCW with Kaplan-Meier, using forest models for both treatment assignment and censoring.
        \item \textbf{G\_formula (Forest / T-learners)}: G-formula with forest models using T-learners.
        \item \textbf{G\_formula (Forest / S-learner)}: G-formula with forest models using an S-learner.
        \item \textbf{AIPTW-AIPCW (Forest)}: Augmented IPTW and IPCW estimator using forest models for both treatment assignment and censoring.
    \end{itemize}

[IM: je sais pas si c'est facile a faire mais dans les figures peut-etre dans l'axe des X les noms des estimateurs pourraient avoir differentes couleurs en fonction de la categorie d'estimateur ou du type de nuisance parameter model?]

@fig-rct1 shows the distribution of the difference in RMST for 100 simulations in Scenario 1 and different sample sizes: 500, 1000, 2000, 4000. We chose to set $\tau = 25$. The corresponding true value of $\theta_{\mathrm{RMST}}$ is indicated by red dotted line.


```{r}
# Flexible function to compile the previous implemented functions in a 
# specified scenario, sample size.
all_estimates <- function(data, sample.size, tau, 
                           X.names.propensity,
                           X.names.censoring,
                           X.names.outcome,
                           nuisance_propensity = "glm", 
                           nuisance_censoring = "cox", 
                           nuisance_survival = "cox", 
                           n.folds = NULL,
                           estimator = "all") {
  
  # List of available estimators
  available_estimators <- c(
    "Naive", "KM", "IPTW KM", "IPCW KM", "BJ", 
    "IPTW-IPCW KM", "IPTW-BJ", "G_formula (T-learners)", 
    "G_formula (S-learner)", "AIPTW-AIPCW", "SurvRM2 - KM", 
    "grf - Causal Survival Forest", "RISCA - IPTW KM", 
    "RISCA - G_formula (S-learner)"
  )
  
  # If estimator is "all", we select all the estimator in available estimators
  if ("all" %in% estimator) {
    estimator <- available_estimators
  }
  
  # Filter the selected estimators
  estimator <- intersect(estimator, available_estimators)
  
  # Store the results in a data frame
  results <- data.frame(
    "sample.size" = numeric(),
    "estimate" = numeric(),
    "estimator" = character(),
    "nuisance" = character()
  )
  
  # Function to extract variable names from I() for squared terms and interaction terms
  extract_vars <- function(names) {
    # Extract names from squared terms
    extracted_squared <- gsub("I\\((.*)\\^2\\)", "\\1", names)  # Replace "I(X^2)" with "X"
    # Extract names from interaction terms (e.g., "X1:X2" becomes "X1" and "X2")
    result_vector <- unique(unlist(strsplit(extracted_squared, ":")))
    return(unique(result_vector))
  }
  # Combine all vectors
  all_names <- c(X.names.propensity, X.names.outcome, X.names.censoring)
  # Apply the extraction function
  X.names <- extract_vars(all_names)
  
  # Each estimator is computed if selected
  # Naive estimator
  if ("Naive" %in% estimator) {
    ATE_naive <- Naive(data, tau)
    results <- rbind(results, data.frame(
      "sample.size" = sample.size, "estimate" = ATE_naive, 
      "estimator" = "Naive", "nuisance" = ""
    ))
  }
  # RMST estimate with undajusted KM
  if ("KM" %in% estimator) {
    ATE_km_rct <- RMST_1(data, tau = tau)
    results <- rbind(results, data.frame(
      "sample.size" = sample.size, "estimate" = ATE_km_rct$RMST, 
      "estimator" = "KM", "nuisance" = ""
    ))
  }
  # RMST estimate with IPTW KM
  if ("IPTW KM" %in% estimator) {
    for (propensity_method in nuisance_propensity) {
      ATE_km_adj <- IPTW_Kaplan_meier(data, tau = tau, 
                                      X.names.propensity = X.names.propensity, 
                                      nuisance_propensity = propensity_method, 
                                      n.folds = n.folds)
      if (propensity_method == "probability forest"){propensity_name = "Forest"}
      else{propensity_name = "Log. Reg."}
      est_name <- paste("IPTW KM (", propensity_name, ")", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_km_adj$RMST, 
        "estimator" = est_name, "nuisance" = propensity_method
      ))
    }
  }
  
  # RMST estimate with IPCW KM
  if ("IPCW KM" %in% estimator) {
    for (censoring_method in nuisance_censoring) {
      ATE_IPCW <- IPCW_Kaplan_meier(data, X.names.censoring = X.names.censoring, 
                                    tau = tau, 
                                    nuisance_censoring = censoring_method, 
                                    n.folds = n.folds)
      if (censoring_method == "survival forest"){censoring_name = "Forest"}
      else{censoring_name = "Cox"}
      est_name <- paste("IPCW KM (", censoring_name, ")", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_IPCW$RMST, 
        "estimator" = est_name , "nuisance" = censoring_method
      ))
    }
  }
  # RMST estimate with BJ pseudo observations
  if ("BJ" %in% estimator) {
    for (survival_method in nuisance_survival) {
      ATE_bj <- BJ(data, tau = tau, 
                   X.names.outcome = X.names.outcome,
                   nuisance = survival_method, 
                   n.folds = n.folds)
      if (survival_method == "survival forest"){survival_name = "Forest"}
      else{survival_name = "Cox"}
      est_name <- paste("BJ (", survival_name, ")", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_bj$RMST, 
        "estimator" = est_name, "nuisance" = survival_method
      ))
    }
  }
  
  # RMST estimate with g-formula two-learners
  if ("G_formula (T-learners)" %in% estimator) {
    for (survival_method in nuisance_survival) {
      ATE_g_formula_t <- g_formula_T_learner(data, tau = tau, 
                                             X.names.outcome = X.names.outcome, 
                                             nuisance_survival = survival_method, 
                                             n.folds = n.folds)
      if (survival_method == "survival forest"){survival_name = "Forest"}
      else{survival_name = "Cox"}
      est_name <- paste("G-formula (", survival_name, "/ T-learners)", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_g_formula_t, 
        "estimator" = est_name, 
        "nuisance" = survival_method
      ))
    }
  }
  
  # RMST estimate with g-formula single learner
  if ("G_formula (S-learner)" %in% estimator) {
    for (survival_method in nuisance_survival) {
      ATE_g_formula_s <- g_formula_S_learner(data, tau = tau, 
                                             X.names.outcome = X.names.outcome, 
                                             nuisance_survival = survival_method, 
                                             n.folds = n.folds)
      if (survival_method == "survival forest"){survival_name = "Forest"}
      else{survival_name = "Cox"}
      est_name <- paste("G-formula (", survival_name, "/ S-learner)", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_g_formula_s, 
        "estimator" = est_name, 
        "nuisance" = survival_method
      ))
    }
  }
  
  
  # RMST estimate with IPTW with pseudo observations (BJ transformation)
  if ("IPTW-BJ" %in% estimator) {
    for (survival_method in nuisance_survival) {
      for (propensity_method in nuisance_propensity) {
        ATE_IPTW_bj <- IPTW_BJ(data, tau = tau, 
                               X.names.propensity = X.names.propensity, 
                               X.names.outcome = X.names.outcome, 
                               nuisance_propensity = propensity_method, 
                               nuisance = survival_method, 
                               n.folds = n.folds)
        if (survival_method == "survival forest"){survival_name = "Forest"}
        else{survival_name = "Cox"}
        if (propensity_method == "probability forest"){propensity_name = "Forest"}
        else{propensity_name = "Log. Reg."}
        if (propensity_name  == survival_name){
          est_name <- paste("IPTW-BJ (", survival_name, ")", sep = "")
        }
        else{
          est_name <- paste("IPTW-BJ (", survival_name," & ", propensity_name , ")", 
                            sep = "")}
        
        
        results <- rbind(results, data.frame(
          "sample.size" = sample.size, "estimate" = ATE_IPTW_bj, 
          "estimator" = est_name, 
          "nuisance" = paste(survival_method, propensity_method, sep = ", ")
        ))
      }
    }
  }
  
  # RMST estimate with IPTW-IPCW KM
  if ("IPTW-IPCW KM" %in% estimator) {
    for (survival_method in nuisance_survival) {
      for (propensity_method in nuisance_propensity) {
        ATE_iptw_ipcw_km <- IPTW_IPCW_Kaplan_meier(data, tau = tau, 
                                                   X.names.propensity = X.names.propensity, 
                                                   X.names.censoring = X.names.censoring, 
                                                   nuisance_propensity = propensity_method, 
                                                   nuisance_censoring = survival_method, 
                                                   n.folds = n.folds)
        if (survival_method == "survival forest"){survival_name = "Forest"}
        else{survival_name = "Cox"}
        if (propensity_method == "probability forest"){propensity_name = "Forest"}
        else{propensity_name = "Log. Reg."}
        if (propensity_name  == survival_name){
          est_name <- paste("IPTW-IPCW KM (", survival_name , ")", 
                            sep = "")
        }
        else{
          est_name <- paste("IPTW-IPCW KM (", survival_name," & ", propensity_name , ")", 
                            sep = "")}
        results <- rbind(results, data.frame(
          "sample.size" = sample.size, "estimate" = ATE_iptw_ipcw_km$RMST, 
          "estimator" = est_name, 
          "nuisance" = paste(survival_method, propensity_method, sep = ", ")
        ))
      }
    }
  }
  
  
  # RMST estimate with AIPTW with pseudo observations (AIPCW transformation)
  if ("AIPTW-AIPCW" %in% estimator) {
    for (survival_method in nuisance_survival) {
      for (propensity_method in nuisance_propensity) {
        for (censoring_method in nuisance_censoring) {
          ATE_aiptw_aipcw <- AIPTW_AIPCW(data, tau = tau, 
                                         X.names.propensity = X.names.propensity, 
                                         X.names.censoring = X.names.censoring, 
                                         X.names.outcome = X.names.outcome,
                                         nuisance_propensity = propensity_method, 
                                         nuisance_censoring = censoring_method, 
                                         nuisance_Qt = survival_method, 
                                         n.folds = n.folds)
          if (survival_method == "survival forest"){survival_name = "Forest"}
          else{survival_name = "Cox"}
          if (propensity_method == "probability forest"){
            propensity_name = "Forest"}
          else{propensity_name = "Log. Reg."}
          if (censoring_method == "survival forest"){
            censoring_name = "Forest"}
          else{censoring_name = "Cox"}
          if (censoring_name == propensity_name & censoring_name == survival_name){
            est_name <- paste("AIPTW-AIPCW (", survival_name, ")", sep = "")
          }
          else{
            est_name <- paste("AIPTW-AIPCW (", survival_name," & ", 
                              censoring_name ," & ", propensity_name , ")", sep = "")}
          results <- rbind(results, data.frame(
            "sample.size" = sample.size, 
            "estimate" = ATE_aiptw_aipcw$AIPTW_AIPCW_IPW_res, 
            "estimator" = est_name, 
            "nuisance" = paste(survival_method, 
                               censoring_method, 
                               propensity_method , sep = ", ")
          ))
        }
      }
    }
  }
  
  # Unadjusted estimate using package from SurvRM2
  if ("SurvRM2 - KM" %in% estimator) {
    ATE_pack <- tryCatch({
      RMST_survRM2(data, tau = tau)
    }, error = function(e) {
      message("Error in ATE_pack: ", e$message)
      return(NA) 
    })
    results <- rbind(results, data.frame(
      "sample.size" = sample.size, "estimate" = ATE_pack, 
      "estimator" = "SurvRM2 - KM", "nuisance" = ""
    ))
  }
  # Estimate using survival random forest from grf
  # CSF can have a mis-specification only on all nuisance parameters
  if ("grf - Causal Survival Forest" %in% estimator) {
    ATE_RF <- tryCatch({
      # If there is no mis-specification, X.names has to be defined as the 
      # union of all the covariates which influence nuisance models
      CSRF(data, X.names, tau = tau)
    }, error = function(e) {
      message("Error in ATE_RF: ", e$message)
      return(NA) 
    })
    results <- rbind(results, data.frame(
      "sample.size" = sample.size, "estimate" = ATE_RF, 
      "estimator" = "grf - Causal Survival Forest", 
      "nuisance" = ""
    ))
  }
  
  if ("RISCA - IPTW KM" %in% estimator) {
    for (propensity_method in nuisance_propensity) {
      # IPTW estimate from RISCA
      ATE_RISCA_iptw <- tryCatch({
        RISCA_iptw(data, X.names.propensity, propensity_method, tau = tau, 
                   n.folds=n.folds)
      }, error = function(e) {
        message("Error in ATE_RISCA_iptw: ", e$message)
        return(NA) 
      })
      if (propensity_method == "probability forest"){propensity_name = "Forest"}
      else{propensity_name = "Log. Reg."}
      est_name <- paste("RISCA - IPTW KM (", propensity_name, ")", sep = "")
      results <- rbind(results, data.frame(
        "sample.size" = sample.size, "estimate" = ATE_RISCA_iptw, 
        "estimator" = est_name, 
        "nuisance" = propensity_method
      ))
    }
  }
  # Only support Cox object
  if ("RISCA - G_formula (S-learner)" %in% estimator) {
    # G-formula estimate from RISCA
    ATE_RISCA_gf <- tryCatch({
      RISCA_gf(data, X.names.outcome, tau = tau)
    }, error = function(e) {
      message("Error in ATE_RISCA_gf: ", e$message)
      return(NA) 
    })
    results <- rbind(results, data.frame(
      "sample.size" = sample.size, "estimate" = ATE_RISCA_gf, 
      "estimator" = "RISCA - G_formula (S-learner)", 
      "nuisance" = "Cox"
    ))
  }
  return(results)
}


# Function to compute estimators for multiple simulations and sample sizes
compute_estimator <- function(n_sim, tau, scenario = "RCT1", 
                              X.names.propensity, 
                              X.names.outcome,
                              X.names.censoring,
                              nuisance_propensity = "glm", 
                              nuisance_censoring = "cox", 
                              nuisance_survival = "cox", 
                              n.folds_propensity = NULL,
                              n.folds_censoring = NULL, 
                              n.folds_survival = NULL, coefC = NULL, 
                              parsC = NULL,
                              parsC_A = NULL,
                              estimator = "all",
                              sample_sizes = c(500, 1000, 2000, 4000, 8000)) {
  
  pb_n <- txtProgressBar(min = 0, max = length(sample_sizes), 
                         style = 3, initial = 0, char = "#")
  on.exit(close(pb_n))
  
  results <- data.frame(
    "sample.size" = numeric(),
    "estimate" = numeric(),
    "estimator" = character(),
    "nuisance" = character()
  )
  
  # Loop through each sample size
  for (idx_n in seq_along(sample_sizes)) {
    n <- sample_sizes[idx_n]
    
    # Progress bar for simulations
    pb <- txtProgressBar(min = 0, max = n_sim, style = 3, initial = 0, char = "#")
    on.exit(close(pb))
    
    # Loop through each simulation
    for (i in 1:n_sim) {
      setTxtProgressBar(pb, i)
      
      # Simulate data based on the scenario
      if (scenario == "RCT1") {
        data <- simulate_data_RCT(n, tau = tau, 
                                  scenario = "RCT1")
      } else if (scenario == "RCT2") {
        data <- simulate_data_RCT(n, tau = tau, 
                                  scenario = "RCT2", 
                                  coefC = coefC, 
                                  parsC = parsC,
                                  parsC_A = parsC_A)
      } else if (scenario == "Obs1") {
        data <- simulate_data_obs(n, tau = tau, 
                                  scenario = "Obs1")
      } else if (scenario == "Obs2") {
        data <- simulate_data_obs(n, tau = tau, 
                                  scenario = "Obs2", 
                                  coefC = coefC, 
                                  parsC = parsC)
      } else if (scenario == "Complex") {
        data <- simulate_data_complex(n, 
                                      tau = tau,
                                      parsC = parsC)
      } else if (scenario == "Mis") {
        data <- simulate_data_mis(n, tau = tau)
      }
      
      
      # Compute all estimates for the simulated data
      all <- all_estimates(data, n, tau = tau, 
                           X.names.propensity, 
                           X.names.outcome,
                           X.names.censoring,
                           nuisance_propensity, 
                           nuisance_censoring,
                           nuisance_survival, 
                           n.folds_propensity = n.folds_propensity, 
                           n.folds_censoring = n.folds_censoring, 
                           n.folds_survival = n.folds_survival,
                           estimator)
      results <- rbind(all, results)
    }
    
    close(pb)
    setTxtProgressBar(pb_n, idx_n)
  }
  
  return(results)
}

```



```{r,eval=FALSE}
# Number of simulations and tau value
n_sim <- 100
tau <- 25

# RCT1 simulation
simulation_rct1 <- compute_estimator(
      n_sim, tau = tau, scenario = "RCT1", 
      X.names.propensity = c("X1", "X2", "X3", "X4"), 
      X.names.outcome = c("X1", "X2", "X3", "X4"),
      X.names.censoring = c("X1", "X2", "X3", "X4"),
      nuisance_propensity = c("glm","probability forest"), 
      nuisance_censoring = c("cox","survival forest"), 
      nuisance_survival = c("cox","survival forest"), 
      n.folds_propensity = 5,
      n.folds_censoring = 5,
      n.folds_survival = 5,
      coefC = 0.03
)
save(simulation_rct1, file = "simulation_rct1.RData")

# RCT2 simulation with specific coefficients and parameters
simulation_rct2 <- compute_estimator(
  n_sim, tau = tau, scenario = "RCT2", 
  X.names.propensity = c("X1", "X2", "X3", "X4"), 
  X.names.outcome = c("X1", "X2", "X3", "X4"),
  X.names.censoring = c("X1", "X2", "X3", "X4"),
  nuisance_propensity = c("glm","probability forest"), 
  nuisance_censoring = c("cox","survival forest"), 
  nuisance_survival = c("cox","survival forest"), 
  n.folds_propensity = 5,
  n.folds_censoring = 5,
  n.folds_survival = 5,
  coefC = 0.03, 
  parsC = c(0.7, 0.3, -0.25, -0.1), 
  parsC_A = c(-0.2)
)
save(simulation_rct2, file = "simulation_rct2.RData")

```

```{r}
load("simulations/results magellan 2/simulation_rct1.RData")
load("simulations/results magellan 2/simulation_rct2.RData")
```


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))

# Define the desired order of the estimators

desired_order <- c(
  "Naive",
  "KM",
  "SurvRM2 - KM",
  "IPTW KM (Log. Reg.)",
  "RISCA - IPTW KM (Log. Reg.)",
  "IPCW KM (Cox)",
  "BJ (Cox)",
  "IPTW-BJ (Cox & Log. Reg.)",
  "IPTW-IPCW KM (Cox & Log. Reg.)",
  "G-formula (Cox/ T-learners)",
  "G-formula (Cox/ S-learner)",
  "RISCA - G_formula (S-learner)",
  "AIPTW-AIPCW (Cox & Cox & Log. Reg.)",
  "grf - Causal Survival Forest",
  "IPTW KM (Forest)",
  "RISCA - IPTW KM (Forest)",
  "IPCW KM (Forest)",
  "BJ (Forest)",
  "IPTW-BJ (Forest)",
  "IPTW-IPCW KM (Forest)",
  "G-formula (Forest/ T-learners)",
  "G-formula (Forest/ S-learner)",
  "AIPTW-AIPCW (Forest)")

# Convert sample size to a factor with levels sorted in decreasing order
simulation_rct1$sample.size <- factor(
  simulation_rct1$sample.size, 
  levels = sort(unique(simulation_rct1$sample.size), decreasing = TRUE)
)

# Convert estimator column to a factor with the specified order
simulation_rct1$estimator <- factor(simulation_rct1$estimator, 
                                    levels = desired_order)

# Create the plot for RCT + independent censoring
simulation_graph_rct1 <- simulation_rct1 %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_tau1, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
theme(
    legend.title = element_blank(), legend.position = "bottom",
    legend.box = "vertical", legend.text = element_text(size = 18),
    axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1),  
    # Adjust text angle for better visibility
    axis.text = element_text(size = 15, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin
  ) +    
  coord_cartesian(ylim = c(0, 15))
  
```

```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}
#| label: fig-rct1
#| fig-cap: "Results of the ATE for the simulation of a RCT with independent censoring."
#| warning: false
simulation_graph_rct1 
```

In this setting, and in accordance to the theory, the simplest estimator (unadjusted KM) performs just as well as the others,and presents an extremely small bias (as derived in @Sec-unadjustedKM).

The naive estimator is biased, as expected, and the bias in both the G-formula (RISCA) and the manual G-formula S-learner implementation arises from a violation of the proportional hazards assumption, as the treatment effect is additive ($T(1) = T(0) + 10$). Since survival times are generated with an exponential distribution [CV: to check la formulation], a Cox model adjustment is well-suited for survival time estimation and can be seen as a correct specification of nuisance parameters. Consequently, the G-formula (Cox/ T-Learners) is highly appropriate, yielding a small-bias estimator across all sample sizes.

[CB: tentative de reformulation -->]
Because the treatment effect is additive, it violates the assumption that $T$ would follow a Cox model in the variables $(X,A)$, whence the very poor performance of both G-formula (Cox/S-learners). However, $T|A=a$ is a Cox-model for $a \in \{0,1\}$, which explain the remarkable performance of G-formula (Cox/T-learners) and some of the other models based on a Cox estimation of $S$. 
[CB: <--]

Other estimators (IPTW KM (Reg.Log), IPCW KM (Cox), IPTW-IPCW KM (Cox & Log.Reg), IPTW-BJ (Cox & Log.Reg), AIPTW-AIPCW (Cox & Cox & Log.Reg))  involve unnecessary nuisance parameter estimates, such as propensity scores or censoring models. Despite this, the performance remains relatively stable in terms of variability, and there are roughly no differences between using (semi-)parametric or non parametric estimation methods for nuisance parameters except for IPCW KM and IPTW-IPCW KM where there is a slight bias when using forests based methods. Regarding G-formula (S-learner/ Forest), it may converge but requires very large sample size. 


```{r echo=FALSE, message=FALSE, warning=FALSE}
# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))


# Convert sample size to a factor with levels sorted in decreasing order
simulation_rct2$sample.size <- factor(
  simulation_rct2$sample.size, 
  levels = sort(unique(simulation_rct2$sample.size), decreasing = TRUE)
)

# Convert estimator column to a factor with the specified order
simulation_rct2$estimator <- factor(simulation_rct2$estimator, 
                                    levels = desired_order)

# Create the plot for RCT + dependent censoring
simulation_graph_rct2 <- simulation_rct2 %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_tau2, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
  theme(
    legend.title = element_blank(), legend.position = "bottom",
    legend.box = "vertical", legend.text = element_text(size = 18),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  
    # Adjust text angle for better visibility
    axis.text = element_text(size = 15, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin
  ) + 
  coord_cartesian(ylim = c(0, 15))
```

```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}
#| label: fig-rct2
#| fig-cap: "Estimation results of the ATE for the simulation of a RCT with dependent censoring."
#| warning: false
simulation_graph_rct2
```

@fig-rct2 shows the results for the  RCT simulation with conditionally independent censoring (Scenario 2). 
In this setting, the Naive estimator remains biased. Similarly, both the
unadjusted Kaplan-Meier (KM) and its SurvRM2 equivalent, as well as the
treatment-adjusted IPTW KM and its RISCA equivalent, are biased due to
their failure to account for dependent censoring. As in Scenario 1, G-formula (Cox/ S-learner) and its RISCA equivalent also remain biased. 
The IPCW KM (Cox) and IPTW-IPCW KM (Cox & Log.Reg.) are slightly biased up to 4,000 observations and very unstable due to extreme censoring probabilities. In contrast, the Buckley-James estimator BJ (Cox), converges
faster and exhibit a small bias even with as few as 500 observations. The BJ
estimator also demonstrates smaller variance than IPCW methods. G-formula (Cox/ T-learners) and AIPCW-AIPTW (Cox \& Cox \& Log.Reg.) estimators seem to perform well, even in small samples.The forest versions of these estimators seem more biased, except Causal Survival Forest and the AIPTW-AIPCW (Forest) highlighting the importance of the choice of nuisance parameter estimation. [CB: comprend pas]
Notably, all estimators exhibit higher variability compared to Scenario 1.


## Observational study with parametric data generating process {#sec-simulation-Obs}

### Data Generating Process

As for Scenarii 1 and 2, we carry out two simulations of an
observational study with both independent and conditional independent censoring. The only difference lies in the simulation of the propensity score, which is no longer constant.
For the simulation, $n$ samples $(X_{i},A_{i},C,T_{i}(0), T_{i}(1))$ are generated as in @sec-simulation-RCT, except:

-   $\operatorname{logit}\{e(X)\}=-1 X_1-1 X_2- 2.5 X_3-1 X_4$ for the
    treatment allocation $(A)$.

-   The hazard for the censoring time $C$:

    -   For scenario 2:
        $\lambda_c(X)=0.03 \cdot \exp \left\{0.7 X_1+0.3 X_2-0.25 X_3-0.1 X_4\right\}$.

The descriptive statistics for the two observational data with independent (\texttt{Obs1}) and conditionally independent censoring (\texttt{Obs2})  are displayed in Appendix (@sec-stat_obs). Note that we did not modify the survival distribution, the target difference in RMST is thus the same.

[CB: euh pourquoi on change C? revoir ce passage pour parler des Scenarii 3 et 4]
[CB: il faut enlever le graphe du RMST car il ne change pas]

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obs1:  Treatment assignment dependent on X + independent censoring
# Obs2:  Treatment assignment dependent on X + dependent censoring (conditional 
# on X)

# Function to simulate observational data for two scenarios: Obs1 and Obs2
simulate_data_obs <- function(n, 
                              mu = c(1, 1, -1, 1), 
                              sigma = diag(4), 
                              colnames_cov = c("X1", "X2", "X3", "X4"),
                              tau,
                              coefT0 = 0.01, 
                              parsS = c(0.5, 0.5, -0.5, 0.5),
                              parsA = c(-1, -1, -2.5, -1), 
                              parsC_A = c(0), 
                              coefC = 0.03,
                              parsC = c(0.7, 0.3, -0.25, -0.1), 
                              scenario = "Obs2") {
  
  # Generate covariates X from a multivariate normal distribution
  X <- mvrnorm(n, mu, sigma)
  X <- as.data.frame(X)
  colnames(X) <- colnames_cov
  
  # Propensity score model based on X
  e <- rowSums(as.matrix(X) %*% diag(parsA))
  e <- plogis(e)  # Transform to probability scale
  
  # Treatment assignment based on the propensity score
  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))
  
  # Outcome model based on X
  X_outcome <- as.matrix(X)
  epsilon <- runif(n, min = 0.00000001, max = 1)
  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))
  
  # Define treatment effect (shift in survival time due to treatment)
  T1 <- T0 + 10
  
  if (scenario == "Obs1") {
    # Scenario 1: Independent censoring
    C <- -log(runif(n, min = 0.00000001, max = 1)) / coefC
    
  } else if (scenario == "Obs2") {
    # Scenario 2: Dependent censoring based on X
    X_censoring <- as.matrix(cbind(X,A))
    parsC <- c(parsC,parsC_A)
    
    C <- -log(runif(n, min = 0.00000001, max = 1)) / 
      (coefC * exp(rowSums(X_censoring %*% diag(parsC))))
    
  } else {
    stop("Invalid scenario. Choose 'Obs1' or 'Obs2'.")
  }
  
  # Determine the true survival time based on treatment
  T_true <- A * T1 + (1 - A) * T0
  
  # Observed time is the minimum of the true survival time and censoring time
  T_obs <- pmin(T_true, C)
  
  # Status indicator: 1 if the event (death) occurred, 0 if censored
  status <- as.numeric(T_true <= C)
  
  # Restricted survival time (censored at tau)
  T_obs_tau <- pmin(T_obs, tau)
  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))
  
  # Compile the simulated data into a data frame
  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, 
                                       status, status_tau, e)
  
  return(DATA_target_population)
}
```


```{r}
# Simulation for scenario Obs1
data_Obs1 <- simulate_data_obs(n = 100000, tau = 25, scenario = "Obs1")

plot_ground_truth(data_Obs1, 
                  vec_tau, 
                  tau, 
                  c(0, 10),
                  "True difference in RMST for Obs scenario 1")

truth_tau3 <-  ground_truth(data_Obs1, tau = 25)
print(paste0("The ground truth for Obs scenario 1 at time 25 is ", round(truth_tau3, 1)))

# Simulation for scenario Obs2 with specific coefficients and parameters
data_Obs2 <- simulate_data_obs(
  n = 100000, tau = tau, scenario = "Obs2", 
  coefC = 0.03, parsC = c(0.7, 0.3, -0.25, -0.1))

plot_ground_truth(data_Obs2, 
                  vec_tau, 
                  tau, 
                  c(0, 10),
                  "True difference in RMST for Obs scenario 2")

truth_tau4 <- ground_truth(data_Obs2, tau = 25)
print(paste0("The ground truth for Obs scenario 2 at time 25 is ", round(truth_tau4, 1)))
```


### Estimation of the RMST


```{r, eval=FALSE}
# Obs1 simulation
simulation_obs1 <- compute_estimator(
  n_sim, tau = tau, scenario = "Obs1", 
  X.names.propensity = c("X1", "X2", "X3", "X4"), 
  X.names.outcome = c("X1", "X2", "X3", "X4"),
  X.names.censoring = c("X1", "X2", "X3", "X4"),
  nuisance_propensity = c("glm","probability forest"), 
  nuisance_censoring = c("cox","survival forest"), 
  nuisance_survival = c("cox","survival forest"), 
  n.folds_propensity = 5,
  n.folds_censoring = 5,
  n.folds_survival = 5,
  coefC = 0.03
)
save(simulation_obs1, file = "simulation_obs1.RData")


# Obs2 simulation with specific coefficients and parameters
simulation_obs2 <- compute_estimator(
  n_sim, tau = tau, scenario = "Obs2", 
  X.names.propensity = c("X1", "X2", "X3", "X4"), 
  X.names.outcome = c("X1", "X2", "X3", "X4"),
  X.names.censoring = c("X1", "X2", "X3", "X4"),
  nuisance_propensity = c("glm","probability forest"), 
  nuisance_censoring = c("cox","survival forest"), 
  nuisance_survival = c("cox","survival forest"), 
  n.folds_propensity = 5,
  n.folds_censoring = 5,
  n.folds_survival = 5,
  coefC = 0.03, 
  parsC = c(0.7, 0.3, -0.25, -0.1)
)
save(simulation_obs2, file = "simulation_obs2.RData")
```


```{r}
load("simulations/results magellan 2/simulation_obs1.RData")
load("simulations/results magellan 2/simulation_obs2.RData")
```

@fig-obs1 below shows the distribution of the estimators of $\theta_{\mathrm{RMST}}$
for the observational study with independent censoring.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))

# Convert sample size to a factor with levels sorted in decreasing order
simulation_obs1$sample.size <- factor(
  simulation_obs1$sample.size, 
  levels = sort(unique(simulation_obs1$sample.size), decreasing = TRUE)
)

# Convert estimator column to a factor with the specified order
simulation_obs1$estimator <- factor(simulation_obs1$estimator, 
                                    levels = desired_order)

# Create the plot for Observational + independent censoring
simulation_graph_obs1 <- simulation_obs1 %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_tau3, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
  theme(
    legend.title = element_blank(), legend.position = "bottom",
    legend.box = "vertical", legend.text = element_text(size = 18),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), 
    axis.text = element_text(size = 15, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin
  ) + 
  coord_cartesian(ylim = c(0, 15))

```

```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}
#| label: fig-obs1
#| fig-cap: "Estimation results of the ATE for the simulation of an observational study with independent censoring."
#| warning: false
simulation_graph_obs1
```

In the simulation of an observational study with independent censoring,
confounding bias is introduced, setting it apart from RCT simulations.
As expected, estimators that fail to adjust for this bias, such as
unadjusted Kaplan-Meier (KM), IPCW KM (Cox), and their equivalents, are
biased. However, estimators like IPTW KM (Log.Reg.), IPTW-IPCW
KM (Cox \& Log. Reg.) are unbiased, even if the latter estimate unecessary nuisance components. IPTW BJ (Cox & Log.Reg) is extremely variable. 

The top-performing estimators in this
scenario are  G-formula (Cox/ T-learners) and AIPCW-AIPTW (Cox & Cox & Log.Reg.), which are unbiased even with 500 observations. The former has the lowest variance. All estimators that use forests to estimate nuisance parameters are biased across sample sizes from 500 to 8000. Although Causal Survival Forest and AIPW-AIPCW (Forest) are expected to eventually converge, they remain extremely demanding in terms of sample size. 


@fig-obs2 below show the distribution of the $\theta_{\mathrm{RMST}}$
estimates for the observational study with conditionally independent
censoring. The red dashed line represents the true $\theta_{\mathrm{RMST}}$ for
$\tau=25$.


```{r echo=FALSE, message=FALSE, warning=FALSE}
# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))

# Convert sample size to a factor with levels sorted in decreasing order
simulation_obs2$sample.size <- factor(
  simulation_obs2$sample.size, 
  levels = sort(unique(simulation_obs2$sample.size), decreasing = TRUE)
)

# Convert estimator column to a factor with the specified order
simulation_obs2$estimator <- factor(simulation_obs2$estimator, 
                                    levels = desired_order)

# Create the plot for Observational + dependent censoring
simulation_graph_obs2 <- simulation_obs2 %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_tau4, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
  theme(
    legend.title = element_blank(), legend.position = "bottom",
    legend.box = "vertical", legend.text = element_text(size = 18),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  
    axis.text = element_text(size = 14, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    plot.margin = unit(c(0, 0, 0, 2.1), "cm") 
  )+  
  coord_cartesian(ylim = c(0, 15))

```

```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}
#| label: fig-obs2
#| fig-cap: "Estimation results of the ATE for the simulation of an observational study with dependent censoring."
#| warning: false
simulation_graph_obs2
```


In the simulation of an observational study with conditionally
independent censoring, estimators that do not account for both censoring
and confounding bias, such as KM, IPCW KM, IPTW KM, and their
package equivalents, are biased. Notably, the IPTW-IPCW KM (Cox & Log.Reg) and IPTW-BJ (Cox & Log.Reg)
estimators remain biased, even with 4,000 observations.

<!--As in prior scenarios, the high censoring rate—approximately 80% in the
treatment group and 50% in the control group—complicates convergence,
especially since IPCW only accounts for uncensored data. The combination
of confounding bias and conditionally independent censoring makes it
difficult for the nuisance models in IPTW-IPCW Kaplan-Meier to converge,
even when correctly specified. Similarly, the bias in the IPTW-BJ
estimator can be attributed to instability from inverse probability
weighting on the estimated complete data, a challenge shared with
IPTW-IPCW Kaplan-Meier. -->

The top-performing estimators in this
scenario are  G-formula (Cox/ T-learners) and AIPCW-AIPTW (Cox & Cox & Log.Reg.), which are unbiased even with 500 observations. The former has the lowest variance as expected [JJ: mettre la ref de la section du resultat theorique sur la plus petite variance de gformula][CV: on a rien mis dans la partie théorique, je trouve pas] . 

Surprisingly, the G-formula (Cox/S-learner) and its equivalent from the RISCA package perform quite competitively, showing only a slight bias despite the violation of the proportional hazards assumption.
<!--This demonstrates that bias
from violating the outcome model's assumptions can vary depending on the
context. -->

All estimators that use forests to estimate nuisance parameters are biased across sample sizes from 500 to 8000. Although Causal Survival Forest and AIPTW-AIPCW (Forest) are expected to eventually converge, they remain extremely demanding in terms of sample size. 


## Observational study with nonlinear relationships and conditionally independent censoring {#sec-nonparametric}

### Data Generating Process

We conduct a simulation in which treatment allocation, as well as the survival and censoring models, are complex and cannot be accurately captured by a simple parametric or semi-parametric model. Instead, these complexities are better estimated using probability forests for the propensity model and survival forests for the conditional survival and censoring models.
Specifically, we generate $n$ samples $(X_{i}, A_{i}, C, T_{i}(0), T_{i}(1))$ in a setup similar to Scenario 4 in @HTE_causal_survival_forests:

-   $X \sim \mathcal{N}\left(\mu=[1,1,1]^{\top}, \Sigma=I_3\right)$.

-   T is generated from a Poisson distribution with mean
    $X_2+X_3+max(0;X_1-0,3)A$.

-   C from a Poisson distribution with mean $1 + log(1 + exp(X_3))$.

-   The propensity score is
    $e(x) = [(1 + exp(-X_1))(1 + exp(-X_2))]^{-1}$

Note that for subjects with
$X_1 < 0,3$, treatment does not affect survival time. The horizon time
$\tau$ is fixed at 2.

```{r echo=TRUE, message=FALSE, warning=FALSE}
simulate_data_complex <- function(n = 2000, tau, parsC = c(0,0,1)){
  # Load necessary library
  library(MASS)
  
  # Generate covariates
  X <- mvrnorm(n, mu = c(1, 1, 1), Sigma = diag(3))
  X <- as.data.frame(X)
  colnames(X) <- c("X1", "X2", "X3")

  # Convert data frame to matrix for matrix operations
  X_treatment <- as.matrix(X)
  
  # Generate treatment
  e <- 1 / ((1 + exp(-X_treatment[, "X1"])) * (1 + exp(-X_treatment[, "X2"])))
  A <- sapply(e, function(p) rbinom(1, size = 1, prob = p))
  
  # Generate potential outcomes
  lambda_1 <- X_treatment[, "X2"] + X_treatment[, "X3"] + 
              pmax(0, X_treatment[, "X1"] - 0.3) * 1
  lambda_0 <- X_treatment[, "X2"] + X_treatment[, "X3"]
  
  T1 <- rpois(n, lambda_1)
  T0 <- rpois(n, lambda_0)
  
  T1[is.na(T1)] <- 0
  T0[is.na(T0)] <- 0
  
  T_true <- T1 * A + T0 * (1 - A)
  
  # Generate censoring time
  lambda_C <- 1 + log(1 + exp(parsC[1]*X_treatment[, "X1"] + 
                                parsC[2]*X_treatment[, "X2"] + 
                                parsC[3]*X_treatment[, "X3"]))
  C <- rpois(n, lambda_C)
  
  # Observed time and status
  T_obs <- pmin(T_true, C)
  status <- as.numeric(T_true <= C)
  censor_status <- as.numeric(T_true > C)
  
  # Restricted survival time
  T_obs_tau <- pmin(T_obs, tau)
  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))
  
  # Create the final data frame
  DATA_target_population <- data.frame(
    X1 = X$X1,
    X2 = X$X2,
    X3 = X$X3,
    tau = tau,
    A = A,
    T1 = T1,
    T0 = T0,
    T_true = T_true,
    C = C,
    T_obs = T_obs,
    T_obs_tau = T_obs_tau,
    status = status,
    censor_status = censor_status,
    status_tau = status_tau,
    e = e
  )
  
  return(DATA_target_population)
}
```


The descriptive statistics for this data is given in Appendix (@sec-stat_complex).

```{r}
# Complex scenario
tau_complex <- 2
vec_tau_complex <- seq(1, 25, by = 1)
data_complex <- simulate_data_complex(n = 150000, tau = tau_complex)
plot_ground_truth(data_complex,
                  vec_tau_complex,
                  tau_complex, 
                  c(0, 1),
                  "True difference in RMST for Obs with non linear scenario")

truth_complex <- ground_truth(data_complex, tau = 2)
print(paste0("The ground truth for Observation with non linear scenario at time 2 is ", round(truth_complex,2)))
```

### Estimation of the RMST

```{r, eval=FALSE}
tau <- 2
simulation_complex <- compute_estimator(
  n_sim, tau = tau, scenario = "Complex", 
  X.names.propensity = c("X1", "X2", "X3"), 
  X.names.outcome = c("X1", "X2", "X3"),
  nuisance_propensity = c("glm","probability forest"), 
  nuisance_censoring = c("cox","survival forest"), 
  nuisance_survival = c("cox","survival forest"), 
  n.folds_propensity = 5,
  n.folds_censoring = 5,
  n.folds_survival = 5,
  parsC = c(0,0,1)
)
save(simulation_complex, file = "simulation_complex.RData")

```


```{r}
load("simulations/results magellan 2/simulation_complex.RData")
```


@fig-complex below show the distribution of the $\theta_{\mathrm{RMST}}$
estimates for the observational study with conditionally independent
censoring in the context of this non-parametric simulation. The red dashed line represents the true
$\theta_{\mathrm{RMST}}$ for $\tau=2$.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))

# Convert sample size to a factor with levels sorted in decreasing order
simulation_complex$sample.size <- factor(
  simulation_complex$sample.size, 
  levels = sort(unique(simulation_complex$sample.size), decreasing = TRUE)
)

# Convert 'estimator' column to a factor with the specified order
simulation_complex$estimator <- factor(simulation_complex$estimator, 
                                    levels = desired_order)

# Create the plot for Observational + dependent censoring in complex simulation
simulation_graph_complex <- simulation_complex %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_complex, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
  theme(
    legend.title = element_blank(), legend.position = "bottom",
    legend.box = "vertical", legend.text = element_text(size = 18),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  
    axis.text = element_text(size = 14, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    plot.margin = unit(c(0, 0, 0, 2.1), "cm") 
  )+  
  coord_cartesian(ylim = c(-0.25, 1))

```

```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}
#| label: fig-complex
#| fig-cap: "Estimation results of the ATE for an observational study with dependent censoring and complex relationships."
#| warning: false
simulation_graph_complex
```


This outcome is quite surprising, as one might expect forest-based methods to outperform others given the data-generating process (DGP). Yet, all methods face significant challenges except for IPTW-BJ (Cox & Log.Reg.). IPTW-BJ (Forest) and Causal Survival Forest also show convergence at 8000 observations. AIPTW-AIPCW (Forest) here exhibits a small biais. G-formula (Forest/T-learners) will also converge but its rate is slower. Lastly, and again unexpectedly, the G-formula (Cox/S-learner) provides satisfactory results despite the proportional hazards assumption being violated. [CV: Je trouve qu'on voit quand même un biais non ?]

<!--[JJ: revoir les commentaires]
In this non-parametric simulation, most nuisance parameters are
estimated using the Cox model and logistic regression, except for the
grf function, which employs non-parametric causal survival forests.
While the propensity score is well captured by logistic regression, the
Cox model struggles to accurately estimate the conditional survival
probability due to the violation of the proportional hazards assumption.
This issue also affects the conditional censoring probability but to a
lesser extent.

The estimators expected to converge under observational and dependent
censoring include IPTW-IPCW Kaplan-Meier, IPTW-BJ, G-formula,
AIPTW-AIPCW, and Causal Survival Forest. IPTW-IPCW shows the most bias,
likely due to the instability of the Cox model in handling conditional
censoring. Despite the proportional hazards violation, the G-formula
S-learner performs well by chance, unlike the T-learner, which exhibits
greater bias. 

IPTW-BJ quickly converges to the true $\theta_{\mathrm{RMST}}$, benefiting from
logistic regression's strong performance in estimating the propensity
score and the Buckley-James transformation’s correction for censored
data. With only 35% of data censored, this estimator converges
effectively even with violation of proportional hazard.

Given the results, AIPTW-AIPCW fails to converge as accurately, since
the well-estimated propensity score alone is insufficient. Overall, only
IPTW-BJ and Causal Survival Forest manage to converge under these
conditions, the latter benefiting from its flexible regression approach
to nuisance estimation.

 As expected, estimators without corrections for
confounding and censoring (Naive, KM, IPTW KM, IPCW KM, BJ, and their
equivalents) remain biased. The IPTW-BJ estimator shows some bias but
converges after 5,000 observations.

Both G-formula (T-learners and S-learners) and Causal Survival Forest
converge after 5,000 observations, with Causal Survival Forest showing
the least bias. As noted by @Foster2011, the Virtual Twins (VT)
estimator (similar to G-formula with survival random forest) lacks
orthogonality [@DML], which compromises its asymptotic properties and
predisposes to bias [@Vaart_1998]. This is supported by
@HTE_causal_survival_forests, showing VT's lower efficiency compared to
causal survival forests, which is consistent with our findings. Thus,
G-formula is not the most efficient estimator in non-parametric
settings.

The S-learner performs better than T-learners, as it uses more
observations by not stratifying by treatment. The finite sample bias
seen across estimators can be attributed to the slower convergence rates
of non-parametric models.

AIPTW-AIPCW continues to perform well, with low variability and few
outliers, though it fluctuates slightly around the true ATE. Despite
this, its bias is smaller compared to other estimators. In this context,
IPTW-BJ performs best asymptotically, while AIPTW-AIPCW converges faster
with finite samples, despite some fluctuations. -->


## Mispecification of nuisance components

### Data Generating Process

We generate an observational study with covariate interactions and conditionally independent censoring. The objective is to assess the impact of misspecifying nuisance components; specifically, we will use models that omit interactions to estimate these components. This approach enables us to evaluate the robustness properties of various estimators.

We generate $n$ samples $(X_{i},A_{i},C,T_{i}(0), T_{i}(1))$ as follows:

-   $X \sim \mathcal{N}\left(\mu=[1,1,-1,1,-2,-5]^{\top}, \Sigma=I_6\right)$.

-   T is generated from an exponential distribution with mean
    $X_1^2 + X_2^2 + X_1 * X_2$.

-   C from an exponential distribution with mean
    $0.1*X_1^2+0.1*X_3^2+X_1*X_3$.

-   The propensity score is
    $e(x) = \frac{1}{1+exp(0.05*X_1-0.01*X_2+1*X_3-0.1X_4)}$.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# DGP for mis-specification 
simulate_data_mis <- function(n, 
                              mu = c(0.5, 0.5, 0.7, 0.5, -0.1, -0.1),
                              sigma =  matrix(c(1, 0, 0, 0, 0, 0, 
                                               0, 1, 0, 0, 0, 0, 
                                               0, 0, 1, 0, 0, 0,
                                               0, 0, 0, 1, 0, 0,
                                               0, 0, 0, 0, 1, 0,
                                               0, 0, 0, 0, 0, 1), 
                                              nrow = 6, byrow = TRUE),
                              colnames_cov = c("X1", "X2", "X3", "X4", "X5", 
                                               "X6"),
                              parsA =  c(0.05, -0.01, 1, -0.1, 0, 0),
                              tau){
  
  # Generate X from a multivariate normal distribution
  X <- MASS::mvrnorm(n, mu, sigma)
  X <- as.data.frame(X)
  colnames(X) <- colnames_cov
  
  # Treatment variable selection: all X
  X_treatment <- as.matrix(X)
  
  # Propensity score model based on X
  e <- parsA[1]*X_treatment[, "X1"] + parsA[2]*X_treatment[, "X2"] + 
    parsA[3]*X_treatment[, "X3"] + parsA[4]*X_treatment[, "X4"] + 
    parsA[5]*X_treatment[, "X5"] + parsA[6]*X_treatment[, "X6"] 
  
  # Logistic regression
  e <- plogis(e)
  
  # Treatment assignment based on the propensity score
  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))
  
  # Outcome variable selection: all X
  X_outcome <- as.matrix(X)
    
  lambda <- X[,1]^2 + X[,2]^2 + X[,1] * X[,2]
  # Simulate the outcome using the cumulative hazard inversion method
  epsilon <- runif(n, min = 1e-8, max = 1)
  T0 <- -log(epsilon) / exp(lambda)
  
  # Simulate independent censoring time
  censoring_lambda <- 0.1*X[,1]^2 + 0.1*X[,3]^2 + X[,3] * X[,1]
  epsilon <- runif(n, min = 1e-8, max = 1)
  C <- -log(epsilon) / exp(censoring_lambda)
  
  
  # T(1) = T(0) + 1
  T1 <- T0 + 1
  
  # True survival time
  T_true <- A * T1 + (1 - A) * T0
  
  # Observed time
  T_obs <- pmin(T_true, C)
  
  # Status indicator
  status <- as.numeric(T_true <= C)
  censor.status <- as.numeric(T_true > C)
  
  # Restricted survival time
  T_obs_tau <- pmin(T_obs, tau)
  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))
    # Compile the simulated data into a data frame
  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, 
                                       status, status_tau, censor.status, e)
  
  return(DATA_target_population)
}
```


The descriptive statistics are given in Appendix (@sec-stat_inter).

```{r}
# Mis scenario 
tau_mis <- 0.5
vec_tau_complex <- seq(0, 10, by = 0.05)
data_mis <- simulate_data_mis(n = 150000, tau = tau_mis)

plot_ground_truth(data_mis,
                  vec_tau_complex, 
                  tau_mis, 
                  c(0, 1), 
                  "True difference in RMST for Mis scenario")

truth_complex_mis <- ground_truth(data_mis, tau = tau_mis)

print(paste0("The ground truth for mis scenario at time 0.45 is ", round(truth_complex_mis,2)))
```


### Estimation of the RMST

<!--In this section, we challenge the estimators in introducing
mis-specification for the nuisance parameters. To do so, the simulation
with interaction is used and mis-specification is introduced by
selecting only one covariate with the less impact on the model. G-formula from RISCA package is removed of the following graph as it cannot introduce interation terms [jj: du coup charlotte je comprends pas ce que tu fais car tu simules avec inyeraction et tu estimes sans interaction donc tu peux utiliser riscaN]. -->

First, we estimate $\theta_{\mathrm{RMST}}$ without any model misspecification to confirm the consistency of the estimators under correctly specified nuisance models. Next, we introduce misspecification individually for the treatment model, censoring model, and outcome model (@fig-mis).
We further examine combined misspecifications for pairs of models: treatment and censoring, treatment and outcome, and outcome and censoring. Finally, we assess the impact of misspecifying all nuisance models simultaneously (@fig-mis2). [CV: mis-specification ou misspecification ?]

```{r eval=FALSE}
n_sim <- 20
tau <- 0.5
# Without mis-specification 
simulation_mis <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X1","X2","X3","X4"), 
  X.names.outcome = c("I(X1^2)", "I(X2^2)", "X1:X2"),
  X.names.censoring = c("I(X1^2)", "I(X3^2)", "X1:X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = c(4000)
)

save(simulation_mis,file="simulation_mis.RData")

# Mis-specification of propensity model
simulation_mis_mistreat <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X2"), 
  X.names.outcome = c("I(X1^2)", "I(X2^2)", "X1:X2"),
  X.names.censoring = c("I(X1^2)", "I(X3^2)", "X1:X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = c(4000)
)

save(simulation_mis_mistreat,file="simulation_mis_mistreat.RData")

# Mis-specification of censoring model
simlulation_miscens <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X1","X2","X3","X4"), 
  X.names.outcome = c("I(X1^2)", "I(X2^2)", "X1:X2"),
  X.names.censoring = c("X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = c(4000)
)

save(simlulation_miscens,file="simulation_mis_miscens.RData")

simulation_mis_misout <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X1","X2","X3","X4"), 
  X.names.outcome = c("X2"),
  X.names.censoring = c("I(X1^2)", "I(X3^2)", "X1:X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = c(4000)
)

save(simulation_mis_misout,file="simulation_mis_misout.RData")
```

```{r}
load("simulations/results magellan 2/simulation_mis.RData")
load("simulations/results magellan 2/simulation_mis_mistreat.RData")
load("simulations/results magellan 2/simulation_mis_miscens.RData")
load("simulations/results magellan 2/simulation_mis_misout.RData")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Define the desired order of the estimators
desired_order_mis <- c(
  "Naive", "KM", "SurvRM2 - KM",
"IPTW KM (Log. Reg.)", "RISCA - IPTW KM (Log. Reg.)",
  "IPCW KM (Cox)", "BJ (Cox)",  "IPTW-BJ (Cox & Log. Reg.)", 
"IPTW-IPCW KM (Cox & Log. Reg.)",
  "G-formula (Cox/ T-learners)", "G-formula (Cox/ S-learner)",
  "AIPTW-AIPCW (Cox & Cox & Log. Reg.)", "grf - Causal Survival Forest"
)

theme_update(plot.title = element_text(hjust = 0.5))

simlulation_mis$sample.size <- factor(simlulation_mis$sample.size, levels = sort(unique(simlulation_mis$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simlulation_mis$estimator <- factor(simlulation_mis$estimator, levels = desired_order_mis)

simulation_graph_mis <- simlulation_mis %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("No mis-specification:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```



```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_mistreat$sample.size <- factor(simlulation_mistreat$sample.size, levels = sort(unique(simlulation_mistreat$sample.size), decreasing = TRUE))


# Convert 'estimator' column to a factor with the specified order
simlulation_mistreat$estimator <- factor(simlulation_mistreat$estimator, levels = desired_order_mis)

simulation_graph_mis_mistreat <- simlulation_mistreat %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of treatment model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```




```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_miscens$sample.size <- factor(simlulation_miscens$sample.size, levels = sort(unique(simlulation_miscens$sample.size), decreasing = TRUE))


# Convert 'estimator' column to a factor with the specified order
simlulation_miscens$estimator <- factor(simlulation_miscens$estimator, levels = desired_order_mis)

simulation_graph_mis_miscens <- simlulation_miscens %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of censoring model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```


```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_misout$sample.size <- factor(simlulation_misout$sample.size, levels = sort(unique(simlulation_misout$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simlulation_misout$estimator <- factor(simlulation_misout$estimator, levels = desired_order_mis)

simulation_graph_mis_misout <- simlulation_misout %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of outcome model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```


```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}
#| label: fig-mis
#| fig-cap: "Estimation results of the ATE for an observational study with dependent censoring in case of a single mis-specification."
#| warning: false
grid.arrange(simulation_graph_mis, simulation_graph_mis_miscens, simulation_graph_mis_misout, simulation_graph_mis_mistreat, ncol = 2, nrow = 2)
```

When there is no mispecification, IPTW-BJ (Cox & Log.Reg) is unbiased. 
IPTW-IPCW KM (Cox & Log.Reg) exhibits a large bias and is not displayed. Surprisingly, G-formula (Cox/ T-learners) and AIPTW-AIPCW (Cox & Cox & Reg.Log) are slightly biased. 

When one nuisance model is mis-specified, [JJ: commenter des qu'on a la figure]

<!--and causal survival forest. In all
these setup, the two estimators are convergent at 4,000 observations. However, the variance of AIPTW-AIPCW is larger when censoring or treatment is mis-specified. 

When the censoring model is mis-specified, the estimators with censoring
correction are still biased as they already struggle to converge without
mis-specification. The other estimators still have the same behavior
than without mis-specification.

When the outcome model is mis-specified, IPTW-BJ estimator becomes
slightly biased. This estimator is not strongly impacted because it uses
the the mis-specified conditional survival function for estimating only
the outcome of censored observation which represents 45% of
observations. Also, the conditional survival is not strongly impacted by
this mis-specification.

As expected, when the treatment model is mis-specified, IPTW-BJ
estimator is biased. -->

```{r eval=FALSE}
n_sim <- 50
tau <- 0.5

# Without mis-specification
simulation_mis_mistreat_out <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X2"), 
  X.names.outcome = c("X2"),
  X.names.censoring = c("I(X1^2)", "I(X3^2)", "X1:X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = c(4000)
)

save(simulation_mis_mistreat_out,file="simulations/results magellan 2/simulation_mis_mistreat_out.RData")

# Mis-specification of censoring 
simlulation_miscens_out <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X1", "X2", "X3", "X4"), 
  X.names.outcome = c( "X2"),
  X.names.censoring = c("X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = 4000
)


# attention à changer
save(simlulation_miscens_out,file="simulations/results magellan 2/simulation_mis_miscens_out.RData")

```

```{r}
load("simulations/results magellan 2/simulation_mis_mistreat_out.RData")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_mistreat_out$sample.size <- factor(simlulation_mistreat_out$sample.size, levels = sort(unique(simlulation_mistreat_out$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simlulation_mistreat_out$estimator <- factor(simlulation_mistreat_out$estimator, levels = desired_order_mis)

simulation_graph_mis_mistreat_out <- simlulation_mistreat_out %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of outcome and treatment model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```

```{r}
load("simulations/results magellan 2/simulation_mis_miscens_out.RData")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_miscens_out$sample.size <- factor(simlulation_miscens_out$sample.size, levels = sort(unique(simlulation_miscens_out$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simlulation_miscens_out$estimator <- factor(simlulation_miscens_out$estimator, levels = desired_order_mis)
#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- "G_formula (S-learner)"

simulation_graph_mis_miscens_out <- simlulation_miscens_out %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of censoring and outcome model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```

```{r eval=FALSE}
n_sim <- 50
tau <- 0.5
simulation_mis_mistreat_cens <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X2"), 
  X.names.outcome = c("I(X1^2)", "I(X2^2)", "X1:X2"),
  X.names.censoring = c("X1","X2"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL,
  n.folds = NULL,
  mis_specification = "none",
  sample_size = 4000
)

save(simulation_mis_mistreat_cens,file="simulations/results magellan 2/simulation_mis_mistreat_cens.RData")

```

```{r}
load("simulations/results magellan 2/simulation_mis_mistreat_cens.RData")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}

theme_update(plot.title = element_text(hjust = 0.5))

simlulation_mistreat_cens$sample.size <- factor(simlulation_mistreat_cens$sample.size, levels = sort(unique(simlulation_mistreat_cens$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simlulation_mistreat_cens$estimator <- factor(simlulation_mistreat_cens$estimator, levels = desired_order_mis)
#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- "G_formula (S-learner)"

simulation_graph_mis_mistreat_cens <- simlulation_mistreat_cens %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of censoring and treatment model:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```


```{r eval=FALSE}
n_sim <- 50
tau <- 0.5
simulation_mis_misall <- compute_estimator(
  n_sim, tau = tau, scenario = "Mis", 
  X.names.propensity = c("X2"), 
  X.names.outcome = c("X2"),
  X.names.censoring = c("X3"),
  nuisance_propensity = "glm",
  nuisance_censoring = "cox",
  nuisance_survival = "cox",
  coefC = NULL, 
  parsC = NULL, 
  n.folds = NULL,
  mis_specification = "none",
  sample_size = 4000
)

save(simulation_mis_misall,file="simulations/results magellan 2/simulation_mis_misall.RData")
```

```{r}
load("simulations/results magellan 2/simulation_mis_misall.RData")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simlulation_misall$sample.size <- factor(simlulation_misall$sample.size, levels = sort(unique(simlulation_misall$sample.size), decreasing = TRUE))


# Convert 'estimator' column to a factor with the specified order
simlulation_misall$estimator <- factor(simlulation_misall$estimator, levels = desired_order_mis)
#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- "G_formula (S-learner)"

simulation_graph_mis_all <- simlulation_misall %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Mis-specification of all models:  ")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex_mis , linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0.3,0.35))

```



```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}
#| label: fig-mis2
#| fig-cap: "Estimation results of the ATE for an observational study with dependent censoring in case of a two or more mis-specifications."
#| warning: false
grid.arrange(simulation_graph_mis_mistreat_out, simulation_graph_mis_miscens_out, simulation_graph_mis_mistreat_cens, simulation_graph_mis_all, ncol = 2, nrow = 2)
```

@fig-mis2 shows that, as expected, when all nuisance models are misspecified, all estimators exhibit bias. AIPTW-AIPCW seems to converge only in cases where either the outcome and treatment models, or the outcome and censoring models, are misspecified, which deviates from initial expectations. It was anticipated that AIPTW-AIPCW would converge solely when both the censoring and treatment models were misspecified. [JJ: modifier au vu du plot]


## Violation of positivity assumption for censoring

[CB: je suis pour enlever cette section car 1/ je pense que c'est assez clair que rien ne marche sans cette hypothese 2/ on ne checke pas les autres hypotheses donc ça m'a l'air assez arbitraire de se concentrer sur la positivité de la censure et 3/ les lois proposées dans cette section ne violent pas cette hypothèse]
In this section, we aim to demonstrate the impact of violating the positivity assumption for censoring on estimator convergence. To enable this violation, we use the same simulation setup as for randomized controlled trials (RCTs) with conditionally independent censoring in  @sec-simulation-RCT (@fig-rct2), as well as for observational studies with conditionally independent censoring in @sec-simulation-Obs (@fig-obs2), but with a stronger dependency on covariates.

-   For  RCTs:
    $\lambda_c(X)=0.002 \cdot \exp \left\{2 X_1- 4 X_2-5 X_3+ 0.2 X_4 - 0.2 A\right\}$.

-   For observational studies:
    $\lambda_c(X)=0.002 \cdot \exp \left\{2 X_1- 4 X_2-5 X_3+ 2 X_4\right\}$.

<!--The violation of positivity censoring can be verified in verifying the
probability of remain uncensored for all combination of covariates (with
cox model if proportional hazard is verified or with survival forest if
not).-->

```{r eval=FALSE}
# rct1
n_sim <- 100 
tau <- 25 
# rct2

simulation_rct2_positivity <- compute_estimator(n_sim = n_sim, 
                                                tau = tau, 
                                                scenario = "RCT2", 
                                                X.names.propensity = c("X1","X2","X3","X4"), 
                                                X.names.outcome = c("X1","X2","X3","X4"),
                                                X.names.censoring = c("X1","X2","X3","X4"),
                                                nuisance_propensity = "glm", 
                                                nuisance_censoring = "cox", 
                                                nuisance_survival = "cox", 
                                                n.folds = NULL, 
                                                coefC = c(0.002), 
                                                parsC_A = c(-0.2),
                                                parsC =  c(2, -4, -5, 0.2),
                                                mis_specification="none",
                                                sample_sizes = 8000)

save(simulation_rct2_positivity,file="simulation_rct2_positivity.RData")

# obs2
simulation_obs2_positivity<-compute_estimator(n_sim = n_sim, 
                                                tau = tau, 
                                                scenario = "Obs2", 
                                                X.names.propensity = c("X1","X2","X3","X4"), 
                                                X.names.outcome = c("X1","X2","X3","X4"),
                                                X.names.censoring = c("X1","X2","X3","X4"),
                                                nuisance_propensity = "glm", 
                                                nuisance_censoring = "cox", 
                                                nuisance_survival = "cox", 
                                                n.folds = NULL, 
                                                coefC = c(0.005),
                                                parsC =  c(5, -4, -7, 2),
                                                mis_specification="none",
                                                sample_sizes = 8000)

save(simulation_obs2_positivity,file="simulation_obs2_positivity.RData")
```

```{r eval=FALSE}
# obs2
n_sim <- 100 
tau <- 3
simulation_complex_positivity<-compute_estimator(n_sim = n_sim, 
                                                tau = tau, 
                                                scenario = "Complex", 
                                                X.names.propensity = c("X1","X2","X3"), 
                                                X.names.outcome = c("X1","X2","X3"),
                                                X.names.censoring = c("X1","X2","X3"),
                                                nuisance_propensity = "probability forest", 
                                                nuisance_censoring = "survival forest", 
                                                nuisance_survival = "survival forest", 
                                                n.folds = 5, 
                                                parsC =  c(-1,-8,-8),
                                                mis_specification="none",
                                                sample_sizes = 8000)

save(simulation_complex_positivity,file="simulation_complex_positivity.RData")
  

```

```{r}
load("simulations/results magellan/simulation_rct2_positivity.RData")
load("simulations/results magellan/simulation_obs2_positivity.RData")
load("simulations/results magellan/simulation_complex_positivity.RData")

```

```{r echo=FALSE, message=FALSE, warning=FALSE}
simulation_rct2_only <- simulation_rct2 %>%
  dplyr:: filter(sample.size == 8000)

theme_update(plot.title = element_text(hjust = 0.5))

simulation_rct2_only$sample.size <- factor(simulation_rct2_only$sample.size, levels = sort(unique(simulation_rct2_only$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simulation_rct2_only$estimator <- factor(simulation_rct2_only$estimator, levels = desired_order)


simulation_graph_rct2_only <- simulation_rct2_only %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("No positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_tau2, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0, 10))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_rct2_positivity$sample.size <- factor(simulation_rct2_positivity$sample.size, levels = sort(unique(simulation_rct2_positivity$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simulation_rct2_positivity$estimator <- factor(simulation_rct2_positivity$estimator, levels = desired_order)

simulation_graph_rct2_positivity<- simulation_rct2_positivity %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_tau2, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0, 10))

```

```{r fig.width=25, fig.height=14}
#| label: fig-posrct2
#| fig-cap: "Estimation results of the ATE for the simulation of a RCT with dependent censoring (parametric relationship) when positivity for censoring is violated."
#| warning: false
grid.arrange(simulation_graph_rct2_only, simulation_graph_rct2_positivity, ncol = 2, nrow = 1)
```

When the censoring positivity assumption is violated in this RCT (@fig-posrct2), all estimators that adjust for censoring using inverse probability weighting (IPCW) methods—such as IPCW KM, IPTW-IPCW KM, and AIPTW-AIPCW—become biased. The causal survival forest shows only a slight bias, while, surprisingly, the G-formula (Cox/T-learners), BJ (Cox), and IPTW-BJ (Cox & Logistic Regression) remain unbiased. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
simulation_obs2_only <- simulation_obs2 %>%
  dplyr:: filter(sample.size == 8000)

theme_update(plot.title = element_text(hjust = 0.5))

simulation_obs2_only$sample.size <- factor(simulation_obs2_only$sample.size, levels = sort(unique(simulation_obs2_only$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simulation_obs2_only$estimator <- factor(simulation_obs2_only$estimator, levels = desired_order)


simulation_graph_obs2_only <- simulation_obs2_only %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("No positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_tau2, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0, 12))
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_obs2_positivity$sample.size <- factor(simulation_obs2_positivity$sample.size, levels = sort(unique(simulation_obs2_positivity$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simulation_obs2_positivity$estimator <- factor(simulation_obs2_positivity$estimator, levels = desired_order)

simulation_graph_obs2_positivity <- simulation_obs2_positivity %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_tau4, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(0, 12))
```

```{r fig.width=25, fig.height=14}
#| label: fig-posobs2
#| fig-cap: "Estimation results of the ATE for the simulation of an observational study with dependent censoring (parametric relationship) when positivity for censoring is violated."
#| warning: false
grid.arrange(simulation_graph_obs2_only, simulation_graph_obs2_positivity, ncol = 2, nrow = 1)
```

The conclusion in the observational case (@fig-posobs2) are similar but despite beeing unbiased IPTW-BJ (Cox) and the G-formula
(Cox/T-learners) pay a price in terms of variance. This apparent unsencitivity to the violation of the positivity assumption for such estimators is valid as soon as the data generating process for the survival time is a Cox model. In a non-parametric setting for DGPs, presented in the boxplots below, all estimators suffers from this violation.

```{r echo=FALSE, message=FALSE, warning=FALSE}
simulation_complex_only <- simulation_complex %>%
  dplyr:: filter(sample.size == 8000)

# Update the theme to center the plot title
theme_update(plot.title = element_text(hjust = 0.5))


# Convert sample size to a factor with levels sorted in decreasing order
simulation_complex_only$sample.size <- factor(
  simulation_complex_only$sample.size, 
  levels = sort(unique(simulation_complex_only$sample.size), decreasing = TRUE)
)

# Convert 'estimator' column to a factor with the specified order
simulation_complex_only$estimator <- factor(simulation_complex_only$estimator, 
                                    levels = desired_order)

# Create the plot for Observational + dependent censoring in complex simulation
simulation_graph_complex_only <- simulation_complex_only %>%
  ggplot(aes(
    x = estimator, y = estimate,  
    fill = factor(sample.size, levels = rev(levels(sample.size)))
  )) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("No positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Change x-axis label
  ylab("ATE") +  # Change y-axis label
  stat_boxplot(geom = "errorbar") +
  geom_hline(
    yintercept = truth_complex, linetype = "dashed", color = "red", 
    alpha = 0.8, size = 0.8
  ) +
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(-0.5, 1))+
   annotate("text", x = 7, y = -0.6, label = "Linear estimation", size = 6, fontface = "bold") +
  annotate("text", x = 18, y = -0.6, label = "Forest estimation", size = 6, fontface = "bold")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
theme_update(plot.title = element_text(hjust = 0.5))

simulation_complex_positivity$sample.size <- factor(simulation_complex_positivity$sample.size, levels = sort(unique(simulation_complex_positivity$sample.size), decreasing = TRUE))

# Convert 'estimator' column to a factor with the specified order
simulation_complex_positivity$estimator <- factor(simulation_complex_positivity$estimator, levels = desired_order)

simulation_graph_complex_positivity <- simulation_complex_positivity %>%
  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +
  scale_fill_brewer(palette = "Accent") +
  ggtitle("Positivity violation")+
  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = "dodge") +
  xlab("") +  # Changer le label de l'axe x
  ylab("ATE") +  # Retirer le label de l'axe y
  stat_boxplot(geom="errorbar")+
  geom_hline(yintercept = truth_complex, linetype = "dashed", color = "red", alpha = 0.8,
             size = 0.8) +  # Changer geom_hline en geom_vline
  theme(legend.title = element_blank(), legend.position = "bottom",
          legend.box = "vertical", legend.text = element_text(size=18),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility
          axis.text = element_text(size=20, face = "bold"),
          plot.title = element_text(size=24, face = "bold"),
          axis.title.x = element_text(size=20, face = "bold"))+
            coord_cartesian(ylim = c(-0.5, 1))
```

```{r fig.width=25, fig.height=14}
#| label: fig-poscomplex
#| fig-cap: "Estimation results of the ATE for the simulation of an observational study with dependent censoring (non-linear relationship) when positivity for censoring is violated."
#| warning: false
grid.arrange(simulation_graph_complex_only, simulation_graph_complex_positivity, ncol = 2, nrow = 1)
```


# Conclusion and perspective

[IM: si je me souviens bien, beaucoup d'estimateurs en analyse de survie ont des problemes quand il y a beaucoup de 'ties' dans les donnees. je rajouterais ici peut-etre une phrase qui en parle et peut-etre meme un peu plus de details sur quels estimateurs soufferaient de la presence de beaucoup de ties et lesquels moins]

[IM: peut-etre ca vaut la peine de reprendre ici l'argument ATE_RMST vs HR et de dire que les estimateurs ATE_RMST existent et ont ete etudies et que l'analyse et le code fourni avec cet article permettront d'etudier davantage l'avantage de ATE_RMST pour l'analyse causale en analyse de survie?]

[IM: et une question naive - sans avoir regarde en detail les preuves en annexe - je me demandais si ce qui compte surtout pour la convergence des differents estimateurs c'est la sample size ou le nombre d'evenements observes dans chaque groupe. est-ce qu'il serait possible de rajouter dans les experiences le nombre d'evenements (moyen) pour chaque sample size et chaque groupe de traitement?]

In this study, we provide implementations for a comprehensive set of estimators to assess treatment effects on survival time using restricted mean survival time, filling a notable gap in available resources. Although demand for causal survival analysis tools is growing, few packages offer robust, diverse estimator options. Our code aims to support further research and practical applications in causal survival analysis, where software options remain limited.

For users, we recommend different estimators based on the context of
their data and modeling assumptions. 

The key insights from this study are as follows: In an **RCT setting** with independent censoring, any causal survival estimator, combined with any method for estimating nuisance parameters, accurately estimates $\theta_{RMST}$, with the exception of the G-formula S-learner, which relies on specific assumptions. However, when censoring is dependent, estimators that fail to account for this are, unsurprisingly, biased. That said, it is reasonable to assume that users may have sufficient information to determine whether censoring is dependent. As a precaution, it is generally advisable to use estimators that accommodate dependent censoring, as the cost of estimating potentially unnecessary nuisance parameters is low (slight increase in variance). In scenarios with dependent censoring, the choice of (semi)-parametric or non-parametric methods for estimating nuisance parameters has a more substantial impact. Notably, causal survival forests and AIPTW-AIPCW forests perform well even when data are generated from simpler models, while other methods struggle. In these cases, the strong performance of BJ (Cox) and the G-formula (Cox/T-learners) is especially noteworthy. In an **observational data setting**, estimators that fail to account for confounders are, predictably, biased. However, users are generally aware of whether they are working within an RCT or an observational framework. In the case of independent censoring, the choice of nuisance parameter estimation becomes critical: Causal Survival Forest, AIPTW-AIPCW (Forest), and G-formula (Forest/T-learners) exhibit slow convergence when data are generated with Cox or logistic models. In this context, only the G-formula (Cox/T-learners) estimator proves to be truly effective. These observations become even more pronounced when censoring is dependent.


<!--"The parametric G-formula shows very good performance, in terms of bias and variability, when the estimation models are well specified.  When the estimation models are mis-specified  the parametric G-formula shows limited bias and not of  a larger magnitude of the non-parametric G formula estimator. The parametric AIPTW-AIPCW estimator, and even more the non-parametric AIPTW-AIPCW show slightly reduced bias, as compared to the parametric G-formula estimator, but at the price of a larger uncertainty."] -->

[JJ: finir commentaire récapitulatif des resulats par exemple sur les mispecifications]

In parametric settings, violations of
positivity tend to have minimal impact for G-formula and IPTW-BJ estimators, as the extrapolation needed to
handle these violations is feasible but risky. However, in
non-parametric contexts, violating the positivity assumption can lead to
erroneous extrapolations, making these estimators unsuitable for use.

Based on the simulations and theoretical results, it would be practical to consider moving away from the IPCW and IPTW-IPCW estimators, as they often exhibit excessive variability. Instead, we recommend implementing Causal Survival Forest, G-formula (T-learners), and AIPTW-AIPCW in both their Cox and Forest versions. By qualitatively combining the results from these more robust estimators, we can expect to gain a fairly accurate understanding of the treatment effect. 

An interesting direction for future work would be to focus on variable selection. Indeed, there is no reason to assume that the variables related to censoring should be the same as those linked to survival or treatment allocation. We could explore differentiating these sets of variables and study the impact on the estimators' variance. Similarly to causal inference settings without survival data, we might expect, for instance, that adding precision variables—those solely related to the outcome—could reduce the variance of the estimators.

[JJ: Donner d'autres perspectives: BJ semble plus interessant quand meme]





```{r eval=FALSE}
library(DiagrammeR)

# Construction de l'arbre de décision avec texte sur les flèches
grViz("
digraph decision_tree {

  # Set up the nodes (shapes)
  node [shape = box, style = filled, fillcolor = lightgray]

  # First level (Observational Study / RCT)
  RCT[label = 'Randomized Clinical Trial', shape = oval]
  Obs[label = 'Observational study', shape = oval]


  # Second level (Independent vs Dependent Censoring for both Obs and RCT)
  Obs_Ind[label = 'Independent Censoring']
  Obs_Dep[label = 'Dependent Censoring']
  RCT_Ind[label = 'Independent Censoring']
  RCT_Dep[label = 'Dependent Censoring']

  # Third level for Independent Censoring (Obs)
  Obs_Ind_Ver[label = 'Verify Positivity of \n Treatment']
  Obs_Ind_Ver_tau[label = 'Lower horizon time']
  Obs_Ind_Formula[label = 'Parametric G-formula + IPTW KM']
  Sens_ana[label = 'Sensitivity analysis']


  # Third level for Dependent Censoring (Obs)
  Obs_Dep_Ver[label = 'Verify Positivity of \n Cens + Treat']
  Obs_Dep_Ver_tau[label = 'Lower horizon time']
  Obs_Dep_Formula[label = 'Parametric G-formula + AIPTW-AIPCW KM']

  
  Obs_Ind_Formula[label = 'Parametric G-formula + IPTW KM']


  # Third level for Independent Censoring (RCT)
  RCT_Ind_Unadj[label = 'Unadjusted KM']

  # Third level for Dependent Censoring (RCT)
  RCT_Dep_Ver[label = 'Verify Positivity of \nCensoring']
  RCT_Dep_Ver_tau[label = 'Lower horizon time']
  RCT_Dep_Formula[label = 'Parametric G-formula + IPCW KM']

  # Connections with labels (text on arrows)
  RCT -> RCT_Ind
  RCT_Ind -> RCT_Ind_Unadj [label = 'No Adj needed']

  RCT -> RCT_Dep
  RCT_Dep -> RCT_Dep_Ver
  RCT_Dep_Ver -> RCT_Dep_Formula [label = 'If verified']
  RCT_Dep_Formula -> Sens_ana
  RCT_Dep_Ver -> RCT_Dep_Ver_tau [label = 'If not verified']
  RCT_Dep_Ver_tau -> RCT_Dep_Ver

  
  Obs -> Obs_Ind
  Obs_Ind -> Obs_Ind_Ver
  Obs_Ind_Ver -> Obs_Ind_Ver_tau [label = 'If not verified']
  Obs_Ind_Ver_tau -> Obs_Ind_Ver
  Obs_Ind_Ver -> Obs_Ind_Formula [label = 'If verified']
  Obs_Ind_Formula -> Sens_ana

  
  Obs -> Obs_Dep
  Obs_Dep -> Obs_Dep_Ver
  Obs_Dep_Ver -> Obs_Dep_Ver_tau [label = 'If not verified']
  Obs_Dep_Ver_tau -> Obs_Dep_Ver
  Obs_Dep_Ver -> Obs_Dep_Formula [label = 'If verified']
  Obs_Dep_Formula -> Sens_ana

}
")
```

A key limitation of our simulations is the use of larger datasets with
relatively simple relationships, which may not reflect the complexity of
real-world scenarios. Most survival analysis datasets are smaller and
more intricate, so the stability of certain estimators observed here may
not fully generalize. It would be valuable to test these methods on
real-world datasets to better assess their performance in practical
applications.

Looking ahead, one promising avenue for improving these estimators is
through optimizing variable selection for the conditional censoring,
conditional survival, and treatment models. It has been shown that
adding precision variables in causal inference enhances the variance of
G-formula-like estimators. A potential area of exploration would be to
investigate whether similar improvements can be made in causal survival
analysis by refining the selection of covariates that influence
censoring and survival outcomes.

# References {.unnumbered}

::: {#refs}
:::


# Appendix A: Proofs  {.appendix}

## Proofs of @sec-theoryRCT_indc {#sec-proof21}

::: {.proof} 
_(@prp-km)._
Consistency is a trivial consequence of the law of large number and the identity [-@eq-kmi]. To show that $\wh S_{\mathrm{KM}}$ is unbiased, let us introduce $\cF_k$ be the filtration generated by the set of variables
$$
\{A_i, I\{\wt T_i = t_j\}, I\{\wt T_i = t_j, \Delta_i=1\}~|~j \in [k], i \in [n]\}.
$$
which corresponds to the known information up to time $t_k$, so that $D_k(a)$ is $\cF_k$-measurable but $N_k(a)$ is $\cF_{k-1}$-measurable. One can write that, for $k\geq 2$
\begin{align*}
\bbE[I\{\wt T_i = t_k, \Delta_i = 1, A_i=a\}~|~\cF_{k-1}] &= \bbE[I\{\wt T_i = t_k, \Delta_i = 1, A_i=a\}~|~I\{\wt T_i \geq t_k\},A_i]  \\
&= I\{A_i=a\} \bbE[I\{T_i = t_k, C_i \geq t_k\}~|~I\{T_i \geq t_k, C_i \geq t_k\}, A_i] \\
&=  I\{A_i=a\} I\{C_i \geq t_k\} \bbE[I\{T_i = t_k\} ~|~ I\{T_i \geq t_k\}, A_i] \\
&= I\{\wt T_i \geq t_k, A_i=a\}\left(1- \frac{S^{(a)}(t_{k})}{S^{(a)}(t_{k-1})}\right),
\end{align*}
where we used that $T_i(a)$ is idependant from $A_i$ by Assumption [-@eq-rta].
We then easily derive from this that
$$
\bbE\left[\left(1-\frac{D_k(a)}{N_k(a)} \right) I\{N_k(a) >0\}\middle |\cF_{k-1}\right] = \frac{S^{(a)}(t_k)}{S^{(a)}(t_{k-1})} I\{N_k(a) >0\},
$$
and then that
$$
\bbE\left[\wh S_{\mathrm{KM}}(t_k|A=a)\middle |\cF_{k-1}\right] =  \frac{S^{(a)}(t_k)}{S^{(a)}(t_{k-1})} \wh S_{\mathrm{KM}}(t_{k-1}|A=a) + O(I\{N_k(a) >0\}),
$$

By induction, we easily find that
$$
\bbE[\wh S_{\mathrm{KM}}(t|A=a)] = \prod_{t_j \leq t} \frac{S^{(a)}(t_j)}{S^{(a)}(t_{j-1})} + O\left(\sum_{t_j \leq t}\bbP(N_j(a) >0)\right)= S^{(a)}(t) + O(\bbP(N_k(a) >0))
$$
where $t_k$ is the greatest time such that $t_k \leq t$.
:::

::: {.proof}
_(@prp-varkm)._
The asymptotic normality is a mere consequence of the joint asymptotic normality of $(N_k(a),D_k(a))_{t_k \leq t}$ with an application of the $\delta$-method. To access the asymptotic variance, notice that, using a similar reasonning as in the previous proof:
\begin{align*}
\bbE[(1-D_k(a)/N_k(a))^2|\cF_{k-1}] &= \bbE[1-D_k(a)/N_k(a)|\cF_{k-1}(a)]^2+\frac{1}{N_k(a)^2}\Var(D_k(a)|\cF_{k-1}) \\
&= s_k^2(a)+ \frac{s_k(a)(1-s_k(a))}{N_k(a)}I\{N_k(a) > 0\} + O(I\{N_k(a) = 0\}). 
\end{align*} 
So that we deduce that
\begin{align*}
n \Var\wh S_{\mathrm{KM}} (t|A=a) &= n \left(\bbE  S_{\mathrm{KM}} (t|A=a)^2 -  S^{(a)} (t)^2 \right) \\
&= n S^{(a)}(t)^2 \left(\bbE\left[\prod_{t_k \leq t} \left(1+\frac{1-s_k(a)}{s_k(a) N_k(a)} I\{N_k(a) > 0\} + O(I\{N_k(a) = 0\}) \right)\right]-1\right).
\end{align*}
Now using that $N_k(a) = n r_k(a) + \sqrt{n} O_{\bbP}(1)$ (with the $O_{\bbP}(1)$ having uniformly bounded variance),  we find that
\begin{align*}
\prod_{t_k \leq t} \left(1+\frac{1-s_k(a)}{s_k(a) N_k(a)}I\{N_k(a) > 0\}+ O(I\{N_k(a) = 0\})\right) &= \prod_{t_k \leq t} \left(1+\frac{1}{n}\frac{1-s_k(a)}{s_k(a)  r_k(a)} + n^{-3/2} O_{\bbP}(1) \right) \\
&= 1 + \frac1n \sum_{t_k \leq t} \frac{1-s_k(a)}{s_k(a)  r_k(a)} + n^{-3/2} O_{\bbP}(1), 
\end{align*}
which in turn yields (because the $O_{\bbP}(1)$ has still uniformly bounded variance):
$$
n \Var\wh S_{\mathrm{KM}} (t|A=a) = V_{\mathrm{KM}}(t|A=a) + o(1),  
$$
which is what we wanted to show.
:::

## Proofs of @sec-condcens {#sec-proof22}

::: {.proof} 
_(@prp-ipcw)._
Assumption [-@eq-positivitycensoring] allows the tranformation to be well-defined. Furthermore, it holds
\begin{align*}
E[T^*_{\mathrm{IPCW}}|A=a,X] 
&= E\left[\frac{ \Delta^\tau \times\widetilde T \wedge \tau}{G(\widetilde T \wedge \tau | A,X)} \middle | A = a,X\right]  \\
&= E\left[\frac{ \Delta^\tau \times T(a) \wedge \tau}{G(T(a) \wedge \tau | A,X)} \middle | A = a,X\right]\\
&= E\left[ E\left[\frac{ I\{T(a)\wedge \tau \leq C \} \times T(a) \wedge \tau}{G(T(a) \wedge \tau | A,X)}\middle| A, X,T(1) \right] \middle | A = a,X\right] \\
&= E\left[T(a) \wedge \tau|A=a, X\right] \\
&= E\left[T \wedge \tau | A=a,X \right].
\end{align*} 
We used in the second equality that on the event $\{\Delta^\tau=1\}$, we have $\widetilde T \wedge \tau =  T \wedge \tau$. We used Assumption [-@eq-sutva] in the second and last inequality to affirm that $T = T(a)$ on the event $A=a$. Finally, we used in the fourth equality that $G(T(a) \wedge \tau | A,X) = E[I\{T(a) \wedge \tau \leq C\}|X,T(a),A]$ thanks to Assumption [-@eq-condindepcensoring].
:::

::: {.proof} 
_(@prp-ipcwkm)._
Similarly to the computations done in the proof of @prp-ipcw, it is easy to show that 
$$
\bbE\left[\frac{\Delta_i^\tau}{G(\wt T \wedge\tau | X,A)} I(\wt T_i = t_k, A=a)\right] = \bbP(A=a) \bbP(T(a) = t_k),
$$
and likewise that
$$
\bbE\left[\frac{\Delta_i^\tau}{G(\wt T \wedge\tau | X,A)} I(\wt T_i \geq t_k, A=a)\right] = \bbP(A=a) \bbP(T(a) \geq t_k),
$$
so that $\wh S_{\mathrm{IPCW}}(t)$ converges almost surely towards the product limit
$$
\prod_{t_k \leq t} \left(1-\frac{\bbP(T(a) = t_k)}{\bbP(T(a) \geq t_k)}\right) = S^{(a)}(t),
$$
yielding strong consistency. Asymptotic normality is straightforward.
:::

::: {.proof} 
_(@prp-bj)._
There holds
\begin{align}
\bbE[T_{\textrm{BJ}}|X,A] &= \bbE \left[\Delta^\tau T + (1-\Delta^\tau)\frac{\bbE[T \wedge \tau \times I\{T \wedge \tau > C\}|C,A,X]}{\bbP(T > C|C,A,X)} \middle | X,A \right] \\
&= \bbE [\Delta^\tau T \wedge \tau | X,A ] +  \bbE \left[ I\{T \wedge \tau > C\} \frac{\bbE[T \wedge \tau \times I\{T \wedge \tau > C\}|C,A,X]}{\bbE[I\{T \wedge \tau \geq C\}|C,A,X]}\middle | X,A \right].
\end{align}
Now we easily see that conditionning wrt $X$ in the second term yields
\begin{align*}
\bbE[T_{\textrm{BJ}}|X,A] &= \bbE [\Delta^\tau T \wedge \tau | X,A ] +  \bbE \left[ \bbE[T \wedge \tau \times I\{T \wedge \tau > C\}|C,A,X] \middle | X,A \right] \\
&= \bbE [\Delta^\tau T \wedge \tau | X,A ] + \bbE [(1-\Delta^\tau) T \wedge \tau | X,A ]  \\
&= \bbE [T \wedge \tau | X,A ], 
\end{align*}
ending the proof.
:::

::: {.proof}
_(@thm-bj)._
We let $T^* = \Delta^\tau \phi_1 + (1-\Delta^\tau)\phi_0$ be a transformation of the form @eq-defcut. There holds
$$
\bbE[(T^*-T \wedge \tau)^2] = \bbE[\Delta^\tau (\phi_1-T \wedge \tau)^2] + \bbE[(1-\Delta^\tau)(\phi_0-T \wedge \tau)^2].
$$
The first term is non negative and is zero for the BJ transformation. Since $\phi_0$ is a function of $(\wt T, X, A)$ and that $\wt T \wedge \tau = C \wedge \tau$ on $\{\Delta^\tau = 1\}$, the second term can be rewritten in the following way. We let $R$ be a generic quantity that does not depend on $\phi_0$.
\begin{align*}
\bbE&[(1-\Delta)(\phi_0-T)^2] = \bbE\left[I\{T\wedge \tau > C\} \phi_0^2 - 2 I\{T\wedge \tau > C\} \phi_0 T \wedge \tau\right]  + R \\
&= \bbE\left[ \bbP(T\wedge \tau > C|C,A,X) \phi_0^2 - 2 \bbE[T\wedge \tau I\{T\wedge \tau > C\}|C,A,X] \phi_0 \right] + R \\
&= \bbE\left[\bbP(T\wedge \tau > C|C,A,X) \left(\phi_0- \frac{\bbE[T\wedge \tau I\{T\wedge \tau > C\}|C,A,X]}{\bbP(T\wedge \tau > C|C,A,X) }\right)^2\right] + R.
\end{align*}
Now the first term in the RHS is always non-negative, and is zero for the BJ tranformation.
:::


## Proofs of @sec-obs_indcen {#sec-proof31}

<!-- ::: {.proof} -->
<!-- _(@prp-iptwkm)._ The fact that it is strongly consistent is again a simple application of the law of large number. The proof of having no bias is essentially the same as in the one of @prp-km, and we borrow the notation $\cF_{k-1}$ from it. We'll show the result for $a=1$, and the proof carries for $a=0$. Letting $\cX$ be the $\sigma$-algebra generated by the covariate $\{X_i\}_{i \in [n]}$, we find that -->
<!-- \begin{align*} -->
<!-- \bbE\left[ \frac{A_i}{e(X_i)} I\{\wt T_i = t_k, \Delta_i = 1\}\middle|\cF_{k-1},\cX\right] &= \frac{A_i}{e(X_i)}\bbE[I\{\wt T_i = t_k, \Delta_i = 1\}|I\{\wt T_i \geq t_k\},A_i,X_i]  \\ -->
<!-- &= \frac{A_i}{e(X_i)}\bbE[I\{T_i = t_k, C_i \geq t_k\}|I\{T_i \geq t_k, C_i \geq t_k\}, A_i, X_i] \\ -->
<!-- &=  \frac{A_i}{e(X_i)} I\{C_i \geq t_k\} \bbE[I\{T_i = t_k\} | I\{T_i \geq t_k\}, A_i,X_i] \\ -->
<!-- &= \frac{A_i}{e(X_i)} I\{\wt T_i \geq t_k\}\left(1- \frac{S^{(1)}(t_{k}|X_i)}{S^{(1)}(t_{k-1}|X_i)}\right), -->
<!-- \end{align*} -->
<!-- where $S^{(1)}(t|X)= \bbP(T(1) > t|X)$ and where we used that $T_i(1)$ is independent from $A_i$ conditionally on $X_i$ by Assumption [-@eq-unconf]. -->
<!-- We then easily derive from this that -->
<!-- $$ -->
<!-- \bbE\left[1-\frac{D_k^{\mathrm{IPTW}}(1)}{N^{\mathrm{IPTW}}_k(1)}\middle |\cF_{k-1},\cX\right] = \frac{S^{(1)}(t_k|X)}{S^{(1)}(t_{k-1}|X)}, -->
<!-- $$ -->
<!-- so that in the end -->
<!-- $$ -->
<!-- \bbE\left[S^*_{\mathrm{IPTW}}(t|A=1)\right] = \bbE\left[ \prod_{t_k \leq t} \frac{S^{(1)}(t_k|X)}{S^{(1)}(t_{k-1}|X)}\right] = \bbE\left[S^{(1)}(t|X) \right] = S^{(1)}(t). -->
<!-- $$ -->
<!-- ::: -->

<!-- ::: {.proof} -->
<!-- _(@prp-variptwkm)._ -->
<!-- We let  -->
<!-- $$ -->
<!-- s_k(X) := \frac{S^{(1)}(t_k|X)}{S^{(1)}(t_{k-1}|X)}. -->
<!-- $$ -->
<!-- Similar computation as in the proof of @prp-varkm show that -->
<!-- $$ -->
<!-- \bbE\left[\left(1-\frac{D_k^{\mathrm{IPTW}}(1)}{N_k^{\mathrm{IPTW}}(1)}\right)^2\right | \cF_{k-1},\cX] = -->
<!-- $$ -->
<!-- ::: -->

<!-- ::: {.proof} -->
<!-- _(@prp-tdr)._ -->

<!-- ::: -->


## Proofs of @sec-obscondcens {#sec-proof32}

::: {.proof}
_(@prp-iptwipcw)._
On the event $\{\Delta^\tau=1, A=1\}$, there holds $\wt T \wedge \tau = T \wedge \tau = T(1) \wedge \tau$, whence we find that
$$
\begin{aligned}
\bbE[T^*_{\mathrm{IPTW-IPCW}}|X,A=1] &= \bbE\left[\frac{A}{e(X)} \frac{I\{T(1) \wedge \tau < C\}}{G(T(1) \wedge \tau|X,A)} T(1) \wedge \tau\middle|X,A=1\right] \\
&= \bbE\left[ \frac{A}{e(X)} \bbE\left[\frac{I\{T(1) \wedge \tau < C\}}{G(T(1) \wedge \tau|X,A)} \middle| X,A, T(1) \right]T(1) \wedge \tau\middle|X,A=1\right] \\
&=\bbE\left[ \frac{A}{e(X)} T(1) \wedge \tau\middle|X,A=1\right] \\
&=\bbE\left[T(1) \wedge \tau\middle|X,A=1\right],
\end{aligned}
$$
and the same holds on the event $A=0$.
:::

::: {.proof}
_(@prp-consiptwipcw)._
By consistency of $\wh G(\cdot|X,A)$ and $\wh e$ and by continuity, it suffices to look at the asymptotic behavior of the oracle estimator
$$
\theta^*_{\mathrm{IPTW-IPCW}} = \frac1n\sum_{i=1}^n  \left(\frac{A_i}{ e(X_i)}-\frac{1-A_i}{1-e(X_i)} \right)\frac{\Delta_i^\tau}{G(\wt T_i \wedge \tau | A_i,X_i)} \wt T_i \wedge \tau.
$$
The later is converging almost towards its mean, which, following similar computations as in the previous proof, write
$$
\begin{aligned}
\bbE\left[\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)} \right)\frac{\Delta^\tau}{G(\wt T \wedge \tau | A,X)} \wt T \wedge \tau\right]  
&= \bbE\left[\left(\frac{A}{e(X)}-\frac{1-A}{1-e(X)} \right) T \wedge \tau\right] \\
&= \bbE\left[T(1) \wedge \tau\right]-\bbE\left[T(0) \wedge \tau\right].
\end{aligned}
$$
:::

::: {.proof}
_(@prp-iptwipcwkm)._
Asymptotic normality comes from a mere application of the $\delta$-method, while strong consistency follows from the law of large number and the follozing computations. Like for the proof of @prp-ipcwkm, one find, by first conditionning wrt $X,A,T(a)$, that
$$
\begin{aligned}
\bbE\left[\left(\frac{A}{e(X)}+\frac{1-A}{1-e(X)} \right)\frac{\Delta^\tau}{G(\wt T \wedge \tau | A,X)} I\{\wt T = t_k, A=a\}\right] = \bbP(T(a)=t_k)
\end{aligned}
$$
and likewise that
$$
\begin{aligned}
\bbE\left[\left(\frac{A}{e(X)}+\frac{1-A}{1-e(X)} \right)\frac{\Delta^\tau}{G(\wt T \wedge \tau | A,X)} I\{\wt T \geq t_k, A=a\}\right] = \bbP(T(a)\geq t_k)
\end{aligned}
$$
so that indeed $S^*_{\mathrm{IPTW-IPCW}} (t|A=a)$ converges almost surely towards $S^{(a)}(t)$.

:::

::: {.proof}
_(@prp-iptwbj)._
We write
$$
\begin{aligned}
\bbE[T^*_{\mathrm{IPTW-BJ}}|X,A=1] &= \bbE\left[\frac{A}{e(X)} \Delta^\tau \times \wt T \wedge \tau\middle|X,A=1\right] + \bbE\left[\frac{A}{e(X)} (1-\Delta^\tau) Q_S(\wt T \wedge \tau|A,X) \middle| X,A=1\right]. 
\end{aligned}
$$
On the event $\{\Delta^\tau=1, A=1\}$, there holds $\wt T \wedge \tau = T \wedge \tau = T(1) \wedge \tau$, whence we find that the first term on the the RHS is equal to
$$
\begin{aligned}
\bbE\left[\frac{A}{e(X)} \Delta^\tau \times \wt T \wedge \tau\middle|X,A=1\right] &= \bbE\left[\frac{A}{e(X)} \Delta^\tau \times T(1) \wedge \tau\middle|X,A=1\right] \\
&= \bbE\left[\Delta^\tau \times T(1) \wedge \tau\middle|X,A=1\right] \\
&= \bbE\left[\Delta^\tau \times T \wedge \tau\middle|X,A=1\right].
\end{aligned}
$$
For the second term in the RHS, notice that on the event $\{\Delta^\tau=0, A=1\}$, there holds $\wt T = C \leq T(1) \wedge \tau$, so that
$$
\begin{aligned}
\bbE&\left[\frac{A}{e(X)} I\{C \leq T(1) \wedge \tau\} \frac{\bbE[T(1) \wedge \tau \times I\{C \leq T(1) \wedge \tau\}|X,A,C]}{\bbP(C \leq T(1) \wedge \tau | C,X,A)} \middle| X,A=1\right] \\
&= \bbE\left[\frac{A}{e(X)} \bbE[T(1) \wedge \tau \times I\{C \leq T(1) \wedge \tau\}|X,A,C] \middle| X,A=1\right] \\
&= \bbE\left[T(1) \wedge \tau \times I\{C \leq T(1) \wedge \tau\} \middle| X,A=1\right] \\
&= \bbE\left[(1-\Delta^\tau) T \wedge \tau  \middle| X,A=1\right], 
\end{aligned}
$$
which ends the proof.
:::

::: {.proof}
_(@prp-consiptwbj)._
By consistency of $\wh G(\cdot|X,A)$ and $\wh e$ and by continuity, it suffices to look at the asymptotic behavior of the oracle estimator
$$
\theta^*_{\mathrm{IPTW-BJ}} = \frac1n\sum_{i=1}^n  \left(\frac{A_i}{ e(X_i)}-\frac{1-A_i}{1-e(X_i)} \right)\left(\Delta_i^\tau \times \wt T_i \wedge \tau + (1-\Delta_i^\tau) Q_S(\wt T_i \wedge \tau|A_i,X_i)\right).
$$
The later is converging almost towards its mean, which, following similar computations as in the previous proof, is simply equal to the RMST.
:::

<!-- ::: {.proof} -->
<!-- _(@prp-tqr)._ -->
<!-- [CB: todo] -->
<!-- ::: -->

# Appendix B {.appendix}

## Descriptive statistics 

### RCT {#sec-stat_RCT}

The summary by group of treatment of the generated (observed and
unobserved) RCT with independent censoring is displayed below:

```{r echo=FALSE, message=FALSE, warning=FALSE}
# data_rct1 simulate the data from RCT with independent censoring 
data_rct1 <- simulate_data_RCT(n=2000,
                               tau=25,
                               scenario="RCT1",
                               coefC = 0.03)
# Stratification by treatment 
group_0 <- data_rct1 %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)

group_1 <- data_rct1 %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)
```

Covariates are balanced between groups, and censoring times are the same
(independent censoring). However, there are more censored observations
in the treated group ($A=1$) than in the control group ($A=0$). This is
due to the higher instantaneous hazard of the event in the treated group
(with $T_1=T_0+10$) compared to the constant hazard of censoring.

The summary of the generated (observed and unobserved)  RCT with
conditionally independent censoring stratified
by treatment is displayed below.

```{r echo=FALSE, message=FALSE, warning=FALSE}

# data_rct2 simulate the data from RCT with dependent censoring 
data_rct2 <- simulate_data_RCT(n=2000,
                               tau=25,
                               scenario="RCT2", 
                               coefC = 0.03, 
                               parsC = c(0.7,0.3,-0.25,-0.1),
                               parsC_A = c(-0.2))


# Stratification by treatment 
group_0 <- data_rct2 %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)

group_1 <- data_rct2 %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)

```

Covariates are balanced between the two groups. However, censoring times
differ between groups due to conditionally independent censoring based
on covariates and treatment group. Indeed, the distribution of $C$ is different between the treatment group. 

### Observational study with linear relationship {#sec-stat_obs}

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Observational data with no informative censoring
data_obs1 <- simulate_data_obs(n = 2000, tau = 25, scenario = "Obs1")

# Observational data simulation with dependent censoring
data_obs2 <- simulate_data_obs(n = 2000, tau = 25, scenario = "Obs2", 
                               coefC = 0.03, parsC = c(0.7,0.3,-0.25,-0.1))

```


The summary of the generated (observed and unobserved) data set
observational study with independent censoring 
stratified by treatment is displayed below to enhance the difference
with the other scenario.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Stratification by treatment 
group_0 <- data_obs1 %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)

group_1 <- data_obs1 %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)

```

The covariates between the two groups of treatment are unbalanced
because of dependent treatment assignation. The mean of $X1$, $X2$, $X3$
and $X4$ is bigger in the control group than in the treated group. The
censoring times have the same distribution (independent censoring).
There are more censored observation in the treated group (A=1) than in
the control group (A=0) for the same reason than in the RCT scenario.

The summary of the generated (observed and unobserved) data set
observational study with conditionally independent censoring stratified by treatment is displayed below.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Stratification by treatment 
group_0 <- data_obs2 %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)

group_1 <- data_obs2 %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)

```

The covariates between the two groups are unbalanced. The censoring time
is dependent on the covariates also, as the covariates are unbalanced
between the two groups, the censoring time is also unbalanced. In
particular, the mean of $X1$, $X2$, $X3$ and $X4$ is bigger in the
control group than in the treated group. Also, the number of events is
bigger in the control than treated group.

### Observational study with non-linear relationship {#sec-stat_complex}

```{r, message=FALSE, warning=FALSE}
complex <- simulate_data_complex(n=2000,tau=2)
```

The summary of the generated (observed and unobserved) data set
observational study with nonlinear relationships and conditionally
independent censoring, stratified by treatment is displayed below.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Stratification by treatment 
group_0 <- complex %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)

group_1 <- complex %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)

```

The observations are the same than the previous scenario: The covariates
and the censoring time between the two groups are unbalanced.
To be able to evaluate the estimators, we need to know the true
$\theta_{\mathrm{RMST}}$ at time $\tau$.


### Observational study with interaction {#sec-stat_inter}


```{r echo=TRUE, message=FALSE, warning=FALSE}
mis <- simulate_data_mis(n=2000,tau=0.5)
summary(mis)
```

The summary of the generated (observed and unobserved) data set complex
observational study (conditionally independent censoring) stratified by
treatment is displayed below.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Stratification by treatment 
group_0 <- mis %>%
  dplyr:: filter(A == 0)%>%
  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)

group_1 <- mis %>%
  dplyr:: filter(A == 1)%>%
  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)

# Summary statistics
summary_group_0 <- summary(group_0)
summary_group_1 <- summary(group_1)

print(paste("Descriptive statistics for group A=0:  ",nrow(group_0)))
print(summary_group_0)

print(paste("Descriptive statistics for group A=1:  ",nrow(group_1)))
print(summary_group_1)

```

The observations are the same than the previous scenario: The covariates
and the censoring time between the two groups are unbalanced.
To be able to evaluate the estimators, we need to know the true
$\theta_{\mathrm{RMST}}$ at time $\tau$.

# Session information {.appendix .unnumbered}

```{r session-info}
sessionInfo()
```

